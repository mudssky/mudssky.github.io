<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Learn how to build a personal website using Next.js"/><meta name="og:title" content="Next.js Sample Website"/><meta name="twitter:card" content="summary_large_image"/><title>4种前端本地存储方法 在浏览器中持久化保存数据</title><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/c0b14c7f598394157d85.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0b14c7f598394157d85.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baf1dedd808a50ceb3ed.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baf1dedd808a50ceb3ed.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-61095c13c5984b221292.js" defer=""></script><script src="/_next/static/chunks/framework-2191d16384373197bc0a.js" defer=""></script><script src="/_next/static/chunks/main-655ad0ce567efa01caa9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-02523805f1f9350d0682.js" defer=""></script><script src="/_next/static/chunks/996-00b4c4d5f8d80ac92fd3.js" defer=""></script><script src="/_next/static/chunks/326-9f57b3028ed8d83c7cdd.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-486a3c6e031a5466d83a.js" defer=""></script><script src="/_next/static/oWv4Rc5CWib8WE-mzU0XV/_buildManifest.js" defer=""></script><script src="/_next/static/oWv4Rc5CWib8WE-mzU0XV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div class="flex justify-between border-b-2 border-gray-50 h-10"><div class="w-16 text-center text-2xl text-blue-500"><a href="/">Blog</a></div><div class="flex w-3/4 justify-end items-center space-x-6"><div class="inline-block h-5 text-sm border-b-2 border-opacity-0 border-green-500 hover:border-opacity-100"><a href="/posts/test">test</a></div><a href="https://github.com/mudssky" target="_blank" rel="noreferrer" class="h-6 flex text-sm mr-4 mt-2 text-gray-600 font-sans font-semibold">GitHub<span class="ml-1 mt-1"><svg class="fill-current text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="15" height="15"><path fill="none" d="M0 0h24v24H0z"></path><path d="M10 6v2H5v11h11v-5h2v6a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm11-3v8h-2V6.413l-7.793 7.794-1.414-1.414L17.585 5H13V3h8z"></path></svg></span></a></div></div><main>前端本地存储 在浏览器中持久化保存数据<br/>2020-01-01<div class="w-1/2 m-auto prose"><h1>4种前端本地存储方法 在浏览器中持久化保存数据</h1>
<p>常见的4种前端存储数据的方式是cookie,LocalStorage,session sorage,IndexedDB</p>
<p>其中sessionStorage有时效性,仅在当前会话有效,当前会话结束后就会删除.</p>
<p>所以实质上,用于长期存储的方式只有3种,</p>
<p>下面放出他们进行对比的表格</p>
<p>其中indexDB相当于本地数据库,所以单独拿出来说</p>
<table><thead><tr><th>对比项目</th><th>cookie</th><th>localstorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>数据存储时间</td><td>可设置失效时间</td><td>永久</td><td>仅当前会话</td></tr><tr><td>容量</td><td>&lt;=4kb</td><td>&lt;=5mb</td><td>&lt;=5mb</td></tr></tbody></table>
<p>其中三种方式都有原生api,其中cookie的原生api比较难用,cookie还有一个特点是会随着请求携带,并且可以被服务端随意修改</p>
<p>因此得出结论,一般网页应用用localstorage就行了,5mb存储一个应用的配置信息还是挺宽裕的.</p>
<p>另外会话中临时会使用的信息就用sessionStorage</p>
<h2>cookie</h2>
<p>cookie的主要属性表格</p>
<table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>Name</td><td>cookie的名称</td></tr><tr><td>Value</td><td>cookie的值,最大容量4Kb</td></tr><tr><td>Domain</td><td>cookie存储的域名</td></tr><tr><td>Path</td><td>cookie存储的路径</td></tr><tr><td>Size</td><td>cookie的大小</td></tr><tr><td>Expires</td><td>过期时间,值可以是UTC格式,可以使用 Date.prototype.toUTCString() 进行转换</td></tr><tr><td>Max-Age</td><td>优先级高于Expires,设置cookie存活的秒数</td></tr><tr><td>HttpOnly</td><td>安全性,设置这个属性后,cookie就不会被js获取到,只有在发起请求时会带上</td></tr><tr><td>Secure</td><td>不需要设置,当协议是https时,自动开启,指定浏览器只有在加密协议 HTTPS 下才能发送cookie\</td></tr><tr><td>SameSite</td><td>跨站策略,设置为Lax,即仅允许同站或子站访问cookie;None:允许所有跨站cookie,设置为Lax会导致第三方cookie失效</td></tr></tbody></table>
<p>cookie的原生api还是比较不人性化的,需要拼接字符串.所以一般我们会进行封装</p>
<p>下面是原生api的封装</p>
<h3>设置cookie</h3>
<pre><code class="language-javascript">/**
 * 设置cookie
 * @param {*} key 名称
 * @param {*} val 值
 * @param {*} time 失效时间
 */

export const setCookie = (key, val, expiresDays) =&gt; {

  var date = new Date();

  //将时间转换为cookie设置时间的格式

  date.setTime(date.getTime() + expiresDays * 24 * 3600 * 1000);

  document.cookie = key + &quot;=&quot; + val + &quot;;expires=&quot; + date.toDateString();
}
</code></pre>
<h3>获取cookie</h3>
<pre><code class="language-javascript">/**
 * 获取cookie
 * @param {*} key 名称
 */

export const getCookie = (key) =&gt; {

  var getCookie = document.cookie.replace(/[ ]/g, &quot;&quot;);

  var arrCookie = getCookie.split(&quot;;&quot;)

  var tips;

  for (var i = 0; i &lt; arrCookie.length; i++) {

    var arr = arrCookie[i].split(&quot;=&quot;);

    if (key == arr[0]) {

      tips = arr[1];

      break;

    }

  }

  return tips;

}
</code></pre>
<h3>删除cookie</h3>
<p>可以直接调用setCookie,把cookie的失效时间设置为-1即可</p>
<pre><code class="language-javascript">setCookie(key,&#x27;&#x27;,-1)
</code></pre>
<h3>利用第三方cookie追踪用户</h3>
<p>cookie执行同源策略</p>
<p>同源的定义为:如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。</p>
<p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<table><thead><tr><th style="text-align:left">URL</th><th style="text-align:left">结果</th><th style="text-align:left">原因</th></tr></thead><tbody><tr><td style="text-align:left"><code>http://store.company.com/dir2/other.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com/dir/inner/another.html</code></td><td style="text-align:left">同源</td><td style="text-align:left">只有路径不同</td></tr><tr><td style="text-align:left"><code>https://store.company.com/secure.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">协议不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com:81/dir/etc.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">端口不同 ( <code>http://</code> 默认端口是80)</td></tr><tr><td style="text-align:left"><code>http://news.company.com/dir/other.html</code></td><td style="text-align:left">失败</td><td style="text-align:left">主机不同</td></tr></tbody></table>
<p>所以说如果在当前网站上你是无法设置和获取不同原的cookie的.</p>
<p>但是我们利用下面两个特性可以实现第三方cookie,追踪用户.</p>
<ul>
<li>服务端可以设置cookie</li>
<li>cookie会随着请求携带</li>
</ul>
<p>举例一个利用第三方cookie的广告</p>
<p>假设a网站引入了一个c的广告组件,这个组件请求另一个网站c的服务端来设置cookie,这时你的浏览器上就有c的cookie了</p>
<p>这时你再访问同样引入c的广告组件的b网站,此时你浏览器上已经有访问a时c的cookie,因此能识别出你是同一个用户,从而给你显示一样的广告.</p>
<h3>cookie 防止XSS攻击</h3>
<p>如果我们的网站没有对用户输入进行过滤,就有可能造成xss攻击.</p>
<p>攻击者可以通过调用document.cookie获取后把我们的cookie发送给攻击者.</p>
<p>但是如果我们设置了HttpOnly属性后,<code>document.cookie</code>就获取不到cookie了,提高了安全性</p>
<h3>cookie会被利用于CSRF攻击</h3>
<p>跨站请求伪造利用了cookie会被请求自动携带的特性.</p>
<p>比如你的电脑中有银行的cookie,你在打开银行的页面的同时,打开了一个钓鱼网站,这个网站包含对银行发起请求的图片标签,直接把你的一大笔钱转走了...因为浏览器在请求银行的时候会自动把cookie带上,这样银行的服务器就会以为是已经登录的用户的请求.</p>
<p>一般为了防止csrf,会增加其他的安全验证token.</p>
<p>或者直接不使用cookie,而使用localStorage,loacalStorage也会被xss利用,所以要注意对用户输入进行过滤.</p>
<h2>localStorage和sessionStorage</h2>
<p>这两个api都是随着html5加入的新api</p>
<p>这两者的主要区别是时效性不同,大小都为5mb</p>
<p>两者的api也是一样的</p>
<p>主要是以key value形式的字符串存储</p>
<h3>缺点</h3>
<p>localStorage的缺点是,只能存入字符串,无法直接存储对象,所以我们每次存入和取出都要重新json处理一下...</p>
<p>而JSON.stringify()我们知道,它对undefined funtion等一些类型无法正常处理,并且不能转换循环引用的对象,因此使用时需要注意.</p>
<h3>存储storage</h3>
<pre><code class="language-JavaScript">/**
 * 存储Storage
 */
export const setStore = (params = {}) =&gt; {
  let {
    name,//名称
    content,//内容
    type,//类型
  } = params;
  let obj = {
    dataType: typeof (content),
    content: content,
    type: type,
    datetime: new Date().getTime()
  }
  if (type) window.sessionStorage.setItem(name, JSON.stringify(obj));
  else window.localStorage.setItem(name, JSON.stringify(obj));
}
</code></pre>
<h3>获取storage</h3>
<pre><code class="language-javascript">/**
 * 判断是否为空
 */
function validatenull (val) {
  if (typeof val === &#x27;boolean&#x27;) {
    return false
  }
  if (typeof val === &#x27;number&#x27;) {
    return false
  }
  if (val instanceof Array) {
    if (val.length == 0) return true
  } else if (val instanceof Object) {
    if (JSON.stringify(val) === &#x27;{}&#x27;) return true
  } else {
    if (val == &#x27;null&#x27; || val == null || val == &#x27;undefined&#x27; || val == undefined || val == &#x27;&#x27;) return true
    return false
  }
  return false
}

/**
 * 获取Storage
 */
export const getStore = (params = {}) =&gt; {
  let {
    name,//名称
    debug//是否需要转换类型
  } = params;
  let obj = {},
    content;
  obj = window.sessionStorage.getItem(name);
  if (validatenull(obj)) obj = window.localStorage.getItem(name);
  if (validatenull(obj)) return;
  try {
    obj = JSON.parse(obj);
  } catch{
    return obj;
  }
  if (debug) {
    return obj;
  }
  if (obj.dataType == &#x27;string&#x27;) {
    content = obj.content;
  } else if (obj.dataType == &#x27;number&#x27;) {
    content = Number(obj.content);
  } else if (obj.dataType == &#x27;boolean&#x27;) {
    content = eval(obj.content);
  } else if (obj.dataType == &#x27;object&#x27;) {
    content = obj.content;
  }
  return content;
}
</code></pre>
<h3>删除storage</h3>
<pre><code class="language-JavaScript">/**
 * 删除localStorage
 */
export const removeStore = (params = {}) =&gt; {
  let {
    name,
    type
  } = params;
  if (type) {
    window.sessionStorage.removeItem(name);
  } else {
    window.localStorage.removeItem(name);
  }
}
</code></pre>
<h3>获取storage</h3>
<pre><code class="language-javascript">/**
 * 获取全部Storage
 */
export const getAllStore = (params = {}) =&gt; {
  let list = [];
  let {
    type
  } = params;
  if (type) {
    for (let i = 0; i &lt;= window.sessionStorage.length; i++) {
      list.push({
        name: window.sessionStorage.key(i),
        content: getStore({
          name: window.sessionStorage.key(i),
          type: &#x27;session&#x27;
        })
      })
    }
  } else {
    for (let i = 0; i &lt;= window.localStorage.length; i++) {
      list.push({
        name: window.localStorage.key(i),
        content: getStore({
          name: window.localStorage.key(i),
        })
      })

    }
  }
  return list;
}
</code></pre>
<h3>清空全部storage</h3>
<pre><code class="language-JavaScript">/**
 * 清空全部Storage
 */
export const clearStore = (params = {}) =&gt; {
  let { type } = params;
  if (type) {
    window.sessionStorage.clear();
  } else {
    window.localStorage.clear()
  }
}
</code></pre>
<h3>localStorage扩容</h3>
<p>LOCALFORAGE是一个兼容性强的本地存储库,它的api类似于localStorage,</p>
<p>它对localStorage,webSQL,和indexedDB做了个平滑升级处理.</p>
<p>默认使用的是indexed和webSQL,在你的浏览器不支持这两个的时候才会降级使用localStorage</p>
<p><a href="https://github.com/localForage/localForage">https://github.com/localForage/localForage</a></p>
<h2>indexedDB</h2>
<p>indexedDB是一个本地关系型数据库.和webStorage同期普及到浏览器的.</p>
<p>算是一个前端的终极本地数据存储方案</p>
<p>对比localStorage,有以下优势</p>
<ul>
<li>存储量理论没有上限(实际上各个浏览器还是会进行一定的限制的)</li>
<li>支持异步操作,性能会更高.</li>
<li>原生支持存储js对象</li>
<li>是个数据库,功能强大</li>
</ul>
<p>indexexDB最大的缺点是,api比较难用,功能繁琐.</p>
<p>一般我们用LOCALFORAGE(<a href="https://github.com/localForage/localForage)%E5%B0%B1%E8%A1%8C%E4%BA%86,%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8indexedDB%E7%9A%84%E5%9C%BA%E5%90%88%E4%B9%9F%E6%AF%94%E8%BE%83%E5%B0%91,%E5%A6%82%E6%9E%9C%E8%BF%99%E6%A0%B7%E9%80%9A%E5%B8%B8%E4%B8%8D%E5%A6%82%E5%81%9A%E6%88%90%E5%AE%A2%E6%88%B7%E7%AB%AF,%E6%88%91%E7%94%A8sqlite%E4%B8%8D%E9%A6%99%E5%90%97">https://github.com/localForage/localForage)就行了,一定要用indexedDB的场合也比较少,如果这样通常不如做成客户端,我用sqlite不香吗</a></p></div><div draggable="true" class="bg-pink-50 fixed shadow rounded w-1/5"><div class="absolute"><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3262" width="22" height="22"><path d="M91.89 238.457c-29.899 0-54.133 24.239-54.133 54.134 0 29.899 24.234 54.137 54.133 54.137s54.138-24.238 54.138-54.137c0-29.896-24.239-54.134-54.138-54.134z" fill="#E5594F" p-id="3263"></path><path d="M91.89 462.463c-29.899 0-54.133 24.239-54.133 54.139 0 29.895 24.234 54.133 54.133 54.133s54.138-24.238 54.138-54.133c0-29.9-24.239-54.139-54.138-54.139z" fill="#C45FA0" p-id="3264"></path><path d="M91.89 686.475c-29.899 0-54.133 24.237-54.133 54.133 0 29.899 24.234 54.138 54.133 54.138s54.138-24.238 54.138-54.138c0-29.896-24.239-54.133-54.138-54.133z" fill="#F39A2B" p-id="3265"></path><path d="M941.26 234.723H328.964c-28.867 0-52.263 23.4-52.263 52.268v3.734c0 28.868 23.396 52.269 52.263 52.269H941.26c28.869 0 52.269-23.401 52.269-52.269v-3.734c-0.001-28.868-23.4-52.268-52.269-52.268z" fill="#F0D043" p-id="3266"></path><path d="M941.26 682.74H328.964c-28.867 0-52.263 23.399-52.263 52.268v3.734c0 28.863 23.396 52.269 52.263 52.269H941.26c28.869 0 52.269-23.405 52.269-52.269v-3.734c-0.001-28.868-23.4-52.268-52.269-52.268z" fill="#4A5699" p-id="3267"></path><path d="M709.781 458.729H328.964c-28.867 0-52.263 23.4-52.263 52.269v3.734c0 28.873 23.396 52.269 52.263 52.269h380.817c28.866 0 52.271-23.396 52.271-52.269v-3.734c0.001-28.869-23.405-52.269-52.271-52.269z" fill="#E5594F" p-id="3268"></path></svg></div><div class="absolute right-0 transition duration-500 transform rotate-180"><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1196" width="22" height="22"><path d="M432.2304 103.2192c-9.216-6.5536-22.016-4.3008-28.5696 4.9152-6.5536 9.216-4.3008 22.016 4.9152 28.5696l59.0848 41.7792 3.2768 2.2528c-71.8848 9.9328-138.3424 42.8032-190.5664 95.0272-63.3856 63.3856-98.2016 147.5584-98.2016 237.1584 0 45.568 9.0112 89.7024 26.7264 131.3792 17.1008 40.1408 41.5744 76.1856 72.704 107.008 3.9936 3.9936 9.216 5.9392 14.4384 5.9392 5.3248 0 10.5472-2.048 14.5408-6.0416 7.9872-7.9872 7.8848-20.992-0.1024-28.9792-56.32-55.7056-87.2448-130.048-87.2448-209.2032 0-78.6432 30.6176-152.576 86.2208-208.1792 46.4896-46.4896 105.8816-75.5712 169.984-83.7632l-2.9696 3.072-52.4288 52.9408c-7.9872 7.9872-7.8848 20.992 0.1024 28.9792 3.9936 3.9936 9.216 5.9392 14.4384 5.9392 5.3248 0 10.5472-2.048 14.5408-6.0416l109.4656-110.4896-130.3552-92.2624zM841.9328 511.0784c0-45.568-9.0112-89.7024-26.7264-131.3792-17.1008-40.1408-41.5744-76.1856-72.704-107.008-3.9936-3.9936-9.216-5.9392-14.4384-5.9392-5.3248 0-10.5472 2.048-14.5408 6.0416-7.9872 7.9872-7.8848 20.992 0.1024 28.9792 56.32 55.7056 87.2448 130.048 87.2448 209.2032 0 78.6432-30.6176 152.576-86.2208 208.1792-46.4896 46.4896-105.8816 75.5712-169.984 83.7632l2.9696-3.072 52.4288-52.9408c7.9872-7.9872 7.8848-20.992-0.1024-28.9792-3.9936-3.9936-9.216-5.9392-14.4384-5.9392-5.3248 0-10.5472 2.048-14.5408 6.0416L461.6192 828.7232l130.1504 92.0576c9.216 6.5536 22.016 4.3008 28.5696-4.9152 6.5536-9.216 4.3008-22.016-4.9152-28.5696l-59.0848-41.7792-3.2768-2.2528c71.8848-9.9328 138.3424-42.8032 190.5664-95.0272 63.3856-63.3856 98.304-147.5584 98.304-237.1584z" p-id="1197"></path></svg></div><ul class="flex flex-col"><li class="font-bold border-b-2 border-gray-300 pl-7 select-none cursor-move">目录</li></ul></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"前端本地存储 在浏览器中持久化保存数据","title":"4种前端本地存储方法 在浏览器中持久化保存数据","date":"2020-01-01","content":"\n\n# 4种前端本地存储方法 在浏览器中持久化保存数据\n\n\n\n常见的4种前端存储数据的方式是cookie,LocalStorage,session sorage,IndexedDB\n\n其中sessionStorage有时效性,仅在当前会话有效,当前会话结束后就会删除.\n\n所以实质上,用于长期存储的方式只有3种,\n\n下面放出他们进行对比的表格\n\n其中indexDB相当于本地数据库,所以单独拿出来说\n\n| 对比项目       | cookie         | localstorage | sessionStorage |\n| -------------- | -------------- | ------------ | -------------- |\n| 数据存储时间   | 可设置失效时间 | 永久         | 仅当前会话     |\n| 容量           | \u003c=4kb          | \u003c=5mb        | \u003c=5mb          |\n\n其中三种方式都有原生api,其中cookie的原生api比较难用,cookie还有一个特点是会随着请求携带,并且可以被服务端随意修改\n\n\n\n因此得出结论,一般网页应用用localstorage就行了,5mb存储一个应用的配置信息还是挺宽裕的.\n\n另外会话中临时会使用的信息就用sessionStorage\n\n\n\n## cookie\n\ncookie的主要属性表格\n\n| key      | value                                                        |\n| -------- | ------------------------------------------------------------ |\n| Name     | cookie的名称                                                 |\n| Value    | cookie的值,最大容量4Kb                                       |\n| Domain   | cookie存储的域名                                             |\n| Path     | cookie存储的路径                                             |\n| Size     | cookie的大小                                                 |\n| Expires  | 过期时间,值可以是UTC格式,可以使用 Date.prototype.toUTCString() 进行转换 |\n| Max-Age  | 优先级高于Expires,设置cookie存活的秒数                       |\n| HttpOnly | 安全性,设置这个属性后,cookie就不会被js获取到,只有在发起请求时会带上 |\n| Secure   | 不需要设置,当协议是https时,自动开启,指定浏览器只有在加密协议 HTTPS 下才能发送cookie\\ |\n| SameSite | 跨站策略,设置为Lax,即仅允许同站或子站访问cookie;None:允许所有跨站cookie,设置为Lax会导致第三方cookie失效 |\n\ncookie的原生api还是比较不人性化的,需要拼接字符串.所以一般我们会进行封装\n\n下面是原生api的封装\n\n### 设置cookie\n\n```javascript\n/**\n * 设置cookie\n * @param {*} key 名称\n * @param {*} val 值\n * @param {*} time 失效时间\n */\n\nexport const setCookie = (key, val, expiresDays) =\u003e {\n\n  var date = new Date();\n\n  //将时间转换为cookie设置时间的格式\n\n  date.setTime(date.getTime() + expiresDays * 24 * 3600 * 1000);\n\n  document.cookie = key + \"=\" + val + \";expires=\" + date.toDateString();\n}\n```\n\n### 获取cookie\n\n```javascript\n/**\n * 获取cookie\n * @param {*} key 名称\n */\n\nexport const getCookie = (key) =\u003e {\n\n  var getCookie = document.cookie.replace(/[ ]/g, \"\");\n\n  var arrCookie = getCookie.split(\";\")\n\n  var tips;\n\n  for (var i = 0; i \u003c arrCookie.length; i++) {\n\n    var arr = arrCookie[i].split(\"=\");\n\n    if (key == arr[0]) {\n\n      tips = arr[1];\n\n      break;\n\n    }\n\n  }\n\n  return tips;\n\n}\n```\n\n### 删除cookie\n\n可以直接调用setCookie,把cookie的失效时间设置为-1即可\n\n```javascript\nsetCookie(key,'',-1)\n```\n\n### 利用第三方cookie追踪用户\n\ncookie执行同源策略\n\n同源的定义为:如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是*同源*。\n\n下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例:\n\n| URL                                               | 结果 | 原因                               |\n| :------------------------------------------------ | :--- | :--------------------------------- |\n| `http://store.company.com/dir2/other.html`        | 同源 | 只有路径不同                       |\n| `http://store.company.com/dir/inner/another.html` | 同源 | 只有路径不同                       |\n| `https://store.company.com/secure.html`           | 失败 | 协议不同                           |\n| `http://store.company.com:81/dir/etc.html`        | 失败 | 端口不同 ( `http://` 默认端口是80) |\n| `http://news.company.com/dir/other.html`          | 失败 | 主机不同                           |\n\n所以说如果在当前网站上你是无法设置和获取不同原的cookie的.\n\n但是我们利用下面两个特性可以实现第三方cookie,追踪用户.\n\n- 服务端可以设置cookie\n- cookie会随着请求携带\n\n举例一个利用第三方cookie的广告\n\n假设a网站引入了一个c的广告组件,这个组件请求另一个网站c的服务端来设置cookie,这时你的浏览器上就有c的cookie了\n\n这时你再访问同样引入c的广告组件的b网站,此时你浏览器上已经有访问a时c的cookie,因此能识别出你是同一个用户,从而给你显示一样的广告.\n\n### cookie 防止XSS攻击\n\n如果我们的网站没有对用户输入进行过滤,就有可能造成xss攻击.\n\n攻击者可以通过调用document.cookie获取后把我们的cookie发送给攻击者.\n\n但是如果我们设置了HttpOnly属性后,`document.cookie`就获取不到cookie了,提高了安全性\n\n### cookie会被利用于CSRF攻击\n\n跨站请求伪造利用了cookie会被请求自动携带的特性.\n\n比如你的电脑中有银行的cookie,你在打开银行的页面的同时,打开了一个钓鱼网站,这个网站包含对银行发起请求的图片标签,直接把你的一大笔钱转走了...因为浏览器在请求银行的时候会自动把cookie带上,这样银行的服务器就会以为是已经登录的用户的请求.\n\n一般为了防止csrf,会增加其他的安全验证token.\n\n或者直接不使用cookie,而使用localStorage,loacalStorage也会被xss利用,所以要注意对用户输入进行过滤.\n\n## localStorage和sessionStorage\n\n这两个api都是随着html5加入的新api\n\n这两者的主要区别是时效性不同,大小都为5mb\n\n两者的api也是一样的\n\n主要是以key value形式的字符串存储\n\n### 缺点\n\nlocalStorage的缺点是,只能存入字符串,无法直接存储对象,所以我们每次存入和取出都要重新json处理一下...\n\n而JSON.stringify()我们知道,它对undefined funtion等一些类型无法正常处理,并且不能转换循环引用的对象,因此使用时需要注意.\n\n\n\n### 存储storage\n\n```JavaScript\n/**\n * 存储Storage\n */\nexport const setStore = (params = {}) =\u003e {\n  let {\n    name,//名称\n    content,//内容\n    type,//类型\n  } = params;\n  let obj = {\n    dataType: typeof (content),\n    content: content,\n    type: type,\n    datetime: new Date().getTime()\n  }\n  if (type) window.sessionStorage.setItem(name, JSON.stringify(obj));\n  else window.localStorage.setItem(name, JSON.stringify(obj));\n}\n```\n\n### 获取storage\n\n```javascript\n/**\n * 判断是否为空\n */\nfunction validatenull (val) {\n  if (typeof val === 'boolean') {\n    return false\n  }\n  if (typeof val === 'number') {\n    return false\n  }\n  if (val instanceof Array) {\n    if (val.length == 0) return true\n  } else if (val instanceof Object) {\n    if (JSON.stringify(val) === '{}') return true\n  } else {\n    if (val == 'null' || val == null || val == 'undefined' || val == undefined || val == '') return true\n    return false\n  }\n  return false\n}\n\n/**\n * 获取Storage\n */\nexport const getStore = (params = {}) =\u003e {\n  let {\n    name,//名称\n    debug//是否需要转换类型\n  } = params;\n  let obj = {},\n    content;\n  obj = window.sessionStorage.getItem(name);\n  if (validatenull(obj)) obj = window.localStorage.getItem(name);\n  if (validatenull(obj)) return;\n  try {\n    obj = JSON.parse(obj);\n  } catch{\n    return obj;\n  }\n  if (debug) {\n    return obj;\n  }\n  if (obj.dataType == 'string') {\n    content = obj.content;\n  } else if (obj.dataType == 'number') {\n    content = Number(obj.content);\n  } else if (obj.dataType == 'boolean') {\n    content = eval(obj.content);\n  } else if (obj.dataType == 'object') {\n    content = obj.content;\n  }\n  return content;\n}\n```\n\n### 删除storage\n\n```JavaScript\n/**\n * 删除localStorage\n */\nexport const removeStore = (params = {}) =\u003e {\n  let {\n    name,\n    type\n  } = params;\n  if (type) {\n    window.sessionStorage.removeItem(name);\n  } else {\n    window.localStorage.removeItem(name);\n  }\n}\n```\n\n### 获取storage\n\n```javascript\n/**\n * 获取全部Storage\n */\nexport const getAllStore = (params = {}) =\u003e {\n  let list = [];\n  let {\n    type\n  } = params;\n  if (type) {\n    for (let i = 0; i \u003c= window.sessionStorage.length; i++) {\n      list.push({\n        name: window.sessionStorage.key(i),\n        content: getStore({\n          name: window.sessionStorage.key(i),\n          type: 'session'\n        })\n      })\n    }\n  } else {\n    for (let i = 0; i \u003c= window.localStorage.length; i++) {\n      list.push({\n        name: window.localStorage.key(i),\n        content: getStore({\n          name: window.localStorage.key(i),\n        })\n      })\n\n    }\n  }\n  return list;\n}\n```\n\n### 清空全部storage\n\n```JavaScript\n/**\n * 清空全部Storage\n */\nexport const clearStore = (params = {}) =\u003e {\n  let { type } = params;\n  if (type) {\n    window.sessionStorage.clear();\n  } else {\n    window.localStorage.clear()\n  }\n}\n```\n\n\n\n### localStorage扩容\n\nLOCALFORAGE是一个兼容性强的本地存储库,它的api类似于localStorage,\n\n它对localStorage,webSQL,和indexedDB做了个平滑升级处理.\n\n默认使用的是indexed和webSQL,在你的浏览器不支持这两个的时候才会降级使用localStorage\n\nhttps://github.com/localForage/localForage\n\n## indexedDB\n\nindexedDB是一个本地关系型数据库.和webStorage同期普及到浏览器的.\n\n算是一个前端的终极本地数据存储方案\n\n对比localStorage,有以下优势\n\n- 存储量理论没有上限(实际上各个浏览器还是会进行一定的限制的)\n- 支持异步操作,性能会更高.\n- 原生支持存储js对象\n- 是个数据库,功能强大\n\nindexexDB最大的缺点是,api比较难用,功能繁琐.\n\n一般我们用LOCALFORAGE(https://github.com/localForage/localForage)就行了,一定要用indexedDB的场合也比较少,如果这样通常不如做成客户端,我用sqlite不香吗\n\n"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"前端本地存储 在浏览器中持久化保存数据"},"buildId":"oWv4Rc5CWib8WE-mzU0XV","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>