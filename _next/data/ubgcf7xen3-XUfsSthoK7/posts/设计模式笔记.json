{"pageProps":{"postData":{"id":"设计模式笔记","title":"设计模式笔记","lastUpdated":1615622092,"content":"\n# design-patterns\n\n- [design-patterns](#design-patterns)\n  - [创造设计模式](#创造设计模式)\n    - [1.🏠简单工厂模式(Simple Factory)](#1简单工厂模式simple-factory)\n      - [现实的例子](#现实的例子)\n      - [简单总结](#简单总结)\n      - [维基百科描述](#维基百科描述)\n      - [typescript example](#typescript-example)\n    - [2.🏭工厂方法模式(Factory Method)](#2工厂方法模式factory-method)\n      - [现实的例子](#现实的例子-1)\n      - [简单总结](#简单总结-1)\n      - [维基百科的描述](#维基百科的描述)\n      - [优缺点](#优缺点)\n      - [伪代码](#伪代码)\n      - [typescript example](#typescript-example-1)\n    - [3.🔨抽象工厂模式  Abstract Factory](#3抽象工厂模式--abstract-factory)\n      - [现实的例子:](#现实的例子-2)\n      - [简单总结](#简单总结-2)\n      - [维基百科的描述](#维基百科的描述-1)\n      - [优缺点](#优缺点-1)\n      - [typescript example](#typescript-example-2)\n    - [4.💍单例模式(Singleton)](#4单例模式singleton)\n      - [现实的例子](#现实的例子-3)\n      - [简单总结](#简单总结-3)\n      - [维基百科的描述](#维基百科的描述-2)\n      - [优缺点](#优缺点-2)\n      - [typescript example](#typescript-example-3)\n    - [5.👷生成器模式(Builder)](#5生成器模式builder)\n      - [现实的例子](#现实的例子-4)\n      - [简单总结](#简单总结-4)\n      - [优缺点](#优缺点-3)\n      - [typescript example](#typescript-example-4)\n    - [6.🐑原型模式(Prototype)](#6原型模式prototype)\n      - [现实的例子](#现实的例子-5)\n      - [简单总结](#简单总结-5)\n      - [适合的使用场景](#适合的使用场景)\n      - [优缺点](#优缺点-4)\n      - [typescript example](#typescript-example-5)\n  - [结构设计模式](#结构设计模式)\n    - [1.☕ 装饰器模式（Decorator）](#1-装饰器模式decorator)\n      - [现实的例子](#现实的例子-6)\n      - [简单总结](#简单总结-6)\n      - [维基百科的解释](#维基百科的解释)\n      - [优缺点](#优缺点-5)\n      - [typescript example](#typescript-example-6)\n    - [2.🔌 适配器模式(Adapter)](#2-适配器模式adapter)\n      - [现实的例子](#现实的例子-7)\n      - [简单总结](#简单总结-7)\n      - [维基百科的描述](#维基百科的描述-3)\n      - [优缺点](#优缺点-6)\n      - [typescript example](#typescript-example-7)\n    - [3.📦 外观模式(Facade)](#3-外观模式facade)\n      - [现实的例子](#现实的例子-8)\n      - [简单总结](#简单总结-8)\n      - [维基百科的描述](#维基百科的描述-4)\n      - [优缺点](#优缺点-7)\n      - [typescript example](#typescript-example-8)\n    - [4.🌿组合模式 (Composite)](#4组合模式-composite)\n      - [现实的例子](#现实的例子-9)\n      - [简单总结](#简单总结-9)\n      - [维基百科的解释](#维基百科的解释-1)\n      - [优缺点](#优缺点-8)\n      - [typescript example](#typescript-example-9)\n    - [5.🎱 代理模式(Proxy)](#5-代理模式proxy)\n      - [现实的例子](#现实的例子-10)\n      - [简单总结](#简单总结-10)\n      - [优缺点](#优缺点-9)\n      - [与其他模式的联系](#与其他模式的联系)\n      - [typescript example](#typescript-example-10)\n    - [6.🚡 桥接模式(Bridge)](#6-桥接模式bridge)\n      - [现实的例子](#现实的例子-11)\n      - [简单总结](#简单总结-11)\n      - [优缺点](#优缺点-10)\n      - [typescript example](#typescript-example-11)\n    - [7.🍃享元模式(Flyweight)](#7享元模式flyweight)\n      - [现实的例子](#现实的例子-12)\n      - [简单总结](#简单总结-12)\n      - [维基百科的解释](#维基百科的解释-2)\n      - [优缺点](#优缺点-11)\n      - [typescript example](#typescript-example-12)\n  - [行为设计模式](#行为设计模式)\n    - [1.💡策略模式(Strategy)](#1策略模式strategy)\n      - [现实例子](#现实例子)\n      - [简单总结](#简单总结-13)\n      - [优缺点](#优缺点-12)\n      - [typescript example](#typescript-example-13)\n      - [golang example](#golang-example)\n      - [dart example](#dart-example)\n    - [2.😎观察者模式(Observer)](#2观察者模式observer)\n      - [现实例子](#现实例子-1)\n      - [简单总结](#简单总结-14)\n      - [维基百科的描述](#维基百科的描述-5)\n      - [优缺点](#优缺点-13)\n      - [typescript example](#typescript-example-14)\n      - [dart example](#dart-example-1)\n      - [golang example](#golang-example-1)\n    - [3.👮命令模式(Command)](#3命令模式command)\n      - [真实世界的例子](#真实世界的例子)\n      - [简单总结](#简单总结-15)\n      - [维基百科的解释](#维基百科的解释-3)\n      - [优缺点](#优缺点-14)\n      - [typescript example](#typescript-example-15)\n    - [4.📒 模板方法(Template Method)](#4-模板方法template-method)\n      - [真实世界的例子](#真实世界的例子-1)\n      - [简单总结](#简单总结-16)\n      - [维基百科的描述](#维基百科的描述-6)\n      - [优缺点](#优缺点-15)\n      - [typescript example](#typescript-example-16)\n    - [5.➿迭代器模式 (Iterator)](#5迭代器模式-iterator)\n      - [现实的例子](#现实的例子-13)\n      - [简单总结](#简单总结-17)\n      - [维基百科的解释](#维基百科的解释-4)\n      - [优缺点](#优缺点-16)\n      - [typescript example](#typescript-example-17)\n    - [6.💢 状态模式(State)](#6-状态模式state)\n      - [现实的例子](#现实的例子-14)\n      - [简单总结](#简单总结-18)\n      - [维基百科的解释](#维基百科的解释-5)\n      - [优缺点](#优缺点-17)\n      - [与其他模式的关系](#与其他模式的关系)\n      - [typescript example](#typescript-example-18)\n    - [7.🔗责任链模式 Chain of Responsibility](#7责任链模式-chain-of-responsibility)\n      - [现实的例子](#现实的例子-15)\n      - [简单总结](#简单总结-19)\n      - [优缺点](#优缺点-18)\n      - [typescript example](#typescript-example-19)\n    - [8.👽中介者模式(Mediator)](#8中介者模式mediator)\n      - [现实的例子](#现实的例子-16)\n      - [简单总结](#简单总结-20)\n      - [优缺点](#优缺点-19)\n      - [typescript example](#typescript-example-20)\n    - [9.💾备忘录模式(Memento)](#9备忘录模式memento)\n      - [现实的例子](#现实的例子-17)\n      - [简单总结](#简单总结-21)\n      - [适合的使用场景](#适合的使用场景-1)\n      - [优缺点](#优缺点-20)\n      - [typescript example](#typescript-example-21)\n    - [10.🏃访问者模式(Visitor)](#10访问者模式visitor)\n      - [现实的例子](#现实的例子-18)\n      - [简单总结](#简单总结-22)\n      - [优缺点](#优缺点-21)\n      - [typescript example](#typescript-example-22)\n\n\n设计模式的类型\n\n- 创造型 （Creational）\n\n- 结构型（Structural）\n\n- 行为型（Behavioral）\n\n## 创造设计模式\n\n创造型设计模式的关注点是如何实例化一个或是一组关联的对象。\n\n创造型有下面几个例子\n\n- Simple Factory\n- Factory Method\n- Abstract Factory\n- Builder\n- Prototype\n- Singleton\n\n### 1.🏠简单工厂模式(Simple Factory)\n\n#### 现实的例子\n\n想象你要造一所房子，你需要一些门，你可以自己准备木头,胶水,你的木匠装备等等，你也可以把工作外包给工厂，让外包制造好门直接交付给你，这样你就不用了解制造门的细节了，也不会因为在家里施工而搞得一团糟。\n\n#### 简单总结\n\n简单工厂模式封装了生成实例的方法，这样用户就可以直接调用这个方法，不需要知道创造实例的逻辑。\n\n(简单工厂实际上不算是一种设计模式,相对于后续介绍的工厂方法来说.)\n\n#### 维基百科描述\n\n在面向对象编程(OOP)中，工厂是用于创建其他对象的对象，形式上工厂是一个函数或方法，它从某个方法调用中返回不同原型或类的对象（这样我们就不用new这些对象来手动创建了）\n\n#### typescript example\n\n```typescript\ninterface Door {\n  getWidth(): number\n  getHeight(): number\n}\nclass WoodenDoor implements Door {\n  protected width: number\n  protected height: number\n  constructor(width: number, height: number) {\n    this.width = width\n    this.height = height\n  }\n  getWidth(): number {\n    return this.width\n  }\n  getHeight(): number {\n    return this.height\n  }\n  deescribe() {\n    console.log(`width:${this.getWidth()},height:${this.getHeight()}`)\n  }\n}\nclass DoorFactory {\n  static makeDoor(width: number, height: number): WoodenDoor {\n    return new WoodenDoor(width, height)\n  }\n}\n\nconst door = DoorFactory.makeDoor(100, 200)\ndoor.deescribe()\nconst door2 = DoorFactory.makeDoor(300, 500)\ndoor2.deescribe()\n\n```\n\n\n\n### 2.🏭工厂方法模式(Factory Method)\n\n**亦称：** 虚拟构造函数、Virtual Constructor\n\n#### 现实的例子\n\n考虑一个HR招人面试的例子,不可能每个职位都由一个人来面试。根据职位空缺，她必须决定并把面试步骤委派给不同的人。\n\n#### 简单总结\n\n工厂方法模式提供了一种将实例化逻辑委托给子类的方法。\n\n#### 维基百科的描述\n\n在基于类的编程中，工厂方法模式是一种创建工厂方法的创建模式，可以处理创建对象的问题而无需指定将创建的对象的确切类别。 这是通过通过调用在接口中指定的工厂方法来创建对象来完成对象，并由子类实现，或者在基类中实现，并且可选地由派生类覆盖 - 而不是通过调用构造函数。\n\n#### 优缺点\n\n**优点**\n\n-  你可以避免创建者和具体产品之间的紧密耦合。\n-  *单一职责原则*。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。\n-  *开闭原则*。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。\n\n**缺点**\n\n-  应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。\n\n#### 伪代码\n\n```javascript\n// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供\n// 该方法的实现。\nclass Dialog is\n    // 创建者还可提供一些工厂方法的默认实现。\n    abstract method createButton():Button\n\n    // 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务\n    // 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方\n    // 法并使其返回不同类型的产品来间接修改业务逻辑。\n    method render() is\n        // 调用工厂方法创建一个产品对象。\n        Button okButton = createButton()\n        // 现在使用产品。\n        okButton.onClick(closeDialog)\n        okButton.render()\n\n\n// 具体创建者将重写工厂方法以改变其所返回的产品类型。\nclass WindowsDialog extends Dialog is\n    method createButton():Button is\n        return new WindowsButton()\n\nclass WebDialog extends Dialog is\n    method createButton():Button is\n        return new HTMLButton()\n\n\n// 产品接口中将声明所有具体产品都必须实现的操作。\ninterface Button is\n    method render()\n    method onClick(f)\n\n// 具体产品需提供产品接口的各种实现。\nclass WindowsButton implements Button is\n    method render(a, b) is\n        // 根据 Windows 样式渲染按钮。\n    method onClick(f) is\n        // 绑定本地操作系统点击事件。\n\nclass HTMLButton implements Button is\n    method render(a, b) is\n        // 返回一个按钮的 HTML 表述。\n    method onClick(f) is\n        // 绑定网络浏览器的点击事件。\n\n\nclass Application is\n    field dialog: Dialog\n\n    // 程序根据当前配置或环境设定选择创建者的类型。\n    method initialize() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == \"Windows\") then\n            dialog = new WindowsDialog()\n        else if (config.OS == \"Web\") then\n            dialog = new WebDialog()\n        else\n            throw new Exception(\"错误！未知的操作系统。\")\n\n    // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口\n    // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子\n    // 类传递给客户端。\n    method main() is\n        this.initialize()\n        dialog.render()\n```\n\n\n\n#### typescript example\n\n下面是这个HR找面试官例子的代码实现\n\nHiringManager抽象类就是工厂类，相当于简单工厂的情况下，把这个工厂方法变抽象，让给外部去继承实现实例化。\n\n```typescript\ninterface Interviewer {\n  askQuestions(): void\n}\n\nclass Developer implements Interviewer {\n  askQuestions(): void {\n    console.log('ask about design patterns!')\n  }\n}\n\nclass CommunityExecutive implements Interviewer {\n  askQuestions(): void {\n    console.log('ask more about community building')\n  }\n}\n\nabstract class HiringManager {\n  protected abstract makeInterviewer(): Interviewer\n  takeInterview() {\n    const interviewer = this.makeInterviewer()\n    interviewer.askQuestions()\n  }\n}\n\nclass DevelopmentManager extends HiringManager {\n  protected makeInterviewer(): Interviewer {\n    return new Developer()\n  }\n}\n\nclass MarketingManager extends HiringManager {\n  protected makeInterviewer(): Interviewer {\n    return new CommunityExecutive()\n  }\n}\n\nconst devManager = new DevelopmentManager()\ndevManager.takeInterview()\n\nconst marketManager = new MarketingManager()\nmarketManager.takeInterview()\n\n```\n\n另一个例子\n\n```typescript\n/**\n * The Creator class declares the factory method that is supposed to return an\n * object of a Product class. The Creator's subclasses usually provide the\n * implementation of this method.\n */\nabstract class Creator {\n    /**\n     * Note that the Creator may also provide some default implementation of the\n     * factory method.\n     */\n    public abstract factoryMethod(): Product;\n\n    /**\n     * Also note that, despite its name, the Creator's primary responsibility is\n     * not creating products. Usually, it contains some core business logic that\n     * relies on Product objects, returned by the factory method. Subclasses can\n     * indirectly change that business logic by overriding the factory method\n     * and returning a different type of product from it.\n     */\n    public someOperation(): string {\n        // Call the factory method to create a Product object.\n        const product = this.factoryMethod();\n        // Now, use the product.\n        return `Creator: The same creator's code has just worked with ${product.operation()}`;\n    }\n}\n\n/**\n * Concrete Creators override the factory method in order to change the\n * resulting product's type.\n */\nclass ConcreteCreator1 extends Creator {\n    /**\n     * Note that the signature of the method still uses the abstract product\n     * type, even though the concrete product is actually returned from the\n     * method. This way the Creator can stay independent of concrete product\n     * classes.\n     */\n    public factoryMethod(): Product {\n        return new ConcreteProduct1();\n    }\n}\n\nclass ConcreteCreator2 extends Creator {\n    public factoryMethod(): Product {\n        return new ConcreteProduct2();\n    }\n}\n\n/**\n * The Product interface declares the operations that all concrete products must\n * implement.\n */\ninterface Product {\n    operation(): string;\n}\n\n/**\n * Concrete Products provide various implementations of the Product interface.\n */\nclass ConcreteProduct1 implements Product {\n    public operation(): string {\n        return '{Result of the ConcreteProduct1}';\n    }\n}\n\nclass ConcreteProduct2 implements Product {\n    public operation(): string {\n        return '{Result of the ConcreteProduct2}';\n    }\n}\n\n/**\n * The client code works with an instance of a concrete creator, albeit through\n * its base interface. As long as the client keeps working with the creator via\n * the base interface, you can pass it any creator's subclass.\n */\nfunction clientCode(creator: Creator) {\n    // ...\n    console.log('Client: I\\'m not aware of the creator\\'s class, but it still works.');\n    console.log(creator.someOperation());\n    // ...\n}\n\n/**\n * The Application picks a creator's type depending on the configuration or\n * environment.\n */\nconsole.log('App: Launched with the ConcreteCreator1.');\nclientCode(new ConcreteCreator1());\nconsole.log('');\n\nconsole.log('App: Launched with the ConcreteCreator2.');\nclientCode(new ConcreteCreator2());\n```\n\n\n\n### 3.🔨抽象工厂模式  Abstract Factory\n\n#### 现实的例子:\n\n回到之间使用的简单工厂的门的例子,您可以从木门商店得到木门，铁门商店或PVC门从相关的商店。另外，你可能需要一个有不同专业的人来装门，例如木匠做木门，焊工做铁门等。正如你所看到的，现在门之间有一个依赖关系，木门需要木匠，铁门需要焊工等等。\n\n#### 简单总结\n\n工厂的工厂,将个别但相关/依赖的工厂分组在一起而不指定它们的具体类的工厂。\n\n#### 维基百科的描述\n\n抽象工厂模式提供了一种方式来封装一组具有公共主题的独立工厂，而无需指定它们的具体类\n\n#### 优缺点\n\n**优点**\n\n- 你可以确保同一工厂生成的产品相互匹配。\n-  你可以避免客户端和具体产品代码的耦合。\n-  *单一职责原则*。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。\n-  *开闭原则*。 向应用程序中引入新产品变体时， 你无需修改客户端代码。\n\n**缺点**\n\n- 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。\n\n#### typescript example\n\n下面是这个木门例子的typescript代码\n\n```typescript\ninterface Door {\n  getDescription(): void\n}\n\nclass WoodenDoor implements Door {\n  getDescription(): void {\n    console.log('I am a wooden door')\n  }\n}\nclass IronDoor implements Door {\n  getDescription(): void {\n    console.log('i am an iron door')\n  }\n}\n\ninterface DoorFittingExpert {\n  getDescription(): void\n}\n\nclass Welder implements DoorFittingExpert {\n  getDescription(): void {\n    console.log('i can only fit iron doors')\n  }\n}\nclass Carpenter implements DoorFittingExpert {\n  getDescription(): void {\n    console.log('i can only fit wooden doors')\n  }\n}\ninterface DoorFactory {\n  makeDoor(): Door\n  makeFittingExpert(): DoorFittingExpert\n}\nclass WoodenDoorFactory implements DoorFactory {\n  makeDoor(): Door {\n    return new WoodenDoor()\n  }\n  makeFittingExpert(): DoorFittingExpert {\n    return new Carpenter()\n  }\n}\n\nclass IronDoorFactory implements DoorFactory {\n  makeDoor(): Door {\n    return new IronDoor()\n  }\n  makeFittingExpert(): DoorFittingExpert {\n    return new Welder()\n  }\n}\n\nconst woodenFactory = new WoodenDoorFactory()\nconst door = woodenFactory.makeDoor()\nconst expert = woodenFactory.makeFittingExpert()\ndoor.getDescription()\nexpert.getDescription()\nexport {}\n\n```\n\n### 4.💍单例模式(Singleton)\n\n**亦称：** 单件模式\n\n#### 现实的例子\n\n一个国家只能有一个总统，总统始终是一个。\n\n#### 简单总结\n\n确保只创建特定类的一个对象。\n\n#### 维基百科的描述\n\n在软件工程中，单例模式是一种软件设计模式，它将类的实例化限制在一个对象中。当只需要一个对象来协调整个系统的操作时，这很有用。\n\n单例模式实际上被认为是反模式，应该避免过度使用它。它并不一定是坏的，可能会有一些有效的用例，但是应该谨慎使用，因为它会在应用程序中引入一个全局状态，在一个地方对它的更改可能会影响到其他区域，并且它可能变得非常难以调试。它们的另一个缺点是它使你的代码紧密耦合，再加上mock单例可能会很困难。\n\n#### 优缺点\n\n**优点**\n\n-  你可以保证一个类只有一个实例。\n-  你获得了一个指向该实例的全局访问节点。\n-  仅在首次请求单例对象时对其进行初始化。\n\n**缺点**\n\n- 违反了_单一职责原则_。 该模式同时解决了两个问题。\n-  单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。\n-  该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。\n-  单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。\n\n#### typescript example\n\n````typescript\nclass President {\n  private static instance: President\n  private constructor() {}\n  static getInstance(): President {\n    if (!this.instance) {\n      this.instance = new this()\n    }\n    return this.instance\n  }\n}\n\nconst president1 = President.getInstance()\nconst president2 = President.getInstance()\nconsole.log(president1 == president2)\n````\n\n### 5.👷生成器模式(Builder)\n\n**亦称：** 建造者模式\n\n#### 现实的例子\n\n例如，你想要一份定制的赛百味套餐，你可以选择几种汉堡的制作方法，比如你想要哪种面包?您喜欢什么酱汁?你想要什么奶酪?等。在这种情况下，构建器模式可以提供帮助。\n\n#### 简单总结\n\n**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n\n#### 优缺点\n\n**优点**\n\n- 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。\n-  生成不同形式的产品时， 你可以复用相同的制造代码。\n-  *单一职责原则*。 你可以将复杂构造代码从产品的业务逻辑中分离出来\n\n**缺点**\n\n- 由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。\n\n#### typescript example\n\n```typescript\nclass Burger {\n  protected size: number\n  protected cheese = false\n  protected pepperoni = false\n  protected lettuce = false\n  protected tomato = false\n  constructor(builder: BurgerBuilder) {\n    this.size = builder.size\n    this.cheese = builder.cheese\n    this.pepperoni = builder.pepperoni\n    this.lettuce = builder.lettuce\n    this.tomato = builder.tomato\n  }\n}\n\nclass BurgerBuilder {\n  size: number\n  cheese = false\n  pepperoni = false\n  lettuce = false\n  tomato = false\n  constructor(size: number) {\n    this.size = size\n  }\n  addPepperoni() {\n    this.pepperoni = true\n    return this\n  }\n  addLettuce() {\n    this.lettuce = true\n    return this\n  }\n  addCheese() {\n    this.cheese = true\n    return this\n  }\n  addTomato() {\n    this.tomato = true\n    return this\n  }\n  build(): Burger {\n    return new Burger(this)\n  }\n}\n\nconst burger = new BurgerBuilder(14).addCheese().addPepperoni().build()\n\n```\n\n### 6.🐑原型模式(Prototype)\n\n**亦称：** 克隆、Clone\n\n#### 现实的例子\n\n还记得多莉?那只克隆羊!我们就不谈细节了，但这里的关键是这都是关于克隆的\n\n#### 简单总结\n\n**原型模式**是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n\n#### 适合的使用场景\n\n**如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。**\n\n 这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。\n\n原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。\n\n\n\n **如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。**\n\n 在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。\n\n客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。\n\n#### 优缺点\n\n**优点**\n\n- 你可以克隆对象， 而无需与它们所属的具体类相耦合。\n-  你可以克隆预生成原型， 避免反复运行初始化代码。\n-  你可以更方便地生成复杂对象。\n-  你可以用继承以外的方式来处理复杂对象的不同配置。\n\n**缺点**\n\n-  克隆包含循环引用的复杂对象可能会非常麻烦。\n\n#### typescript example\n\n```typescript\nclass Sheep {\n  protected name: string\n  protected category: string\n  constructor(name: string, category = 'Mountain Sheep') {\n    this.name = name\n    this.category = category\n  }\n  setName(name: string) {\n    this.name = name\n  }\n  getName() {\n    return this.name\n  }\n  setCategory(category: string) {\n    this.category = category\n  }\n  getCategory() {\n    return this.category\n  }\n}\n\nconst original = new Sheep('Jolly')\nconsole.log(`name:${original.getName()}, category: ${original.getCategory()}`)\n\n// 需要调用一个深拷贝方法，js原生并没有这种方法\n\n```\n\n\n\n## 结构设计模式\n\n结构设计模式主要关注对象组合，换句话说，实体如何相互使用。或者另一种解释是，它们有助于回答“如何构建软件组件”\n\n### 1.☕ 装饰器模式（Decorator）\n\n**亦称：** 装饰者模式、装饰器模式、Wrapper、Decorator\n\n#### 现实的例子\n\n假设你经营一家咖啡店，计算账单的时候需要根据添加的各种原料计算最终的成本，这个情况下，每个添加的原料可以作为装饰器\n\n（实际上碰到这种例子，查表就可以了吧，价格不必硬编码到程序里）\n\n#### 简单总结\n\n装饰器模式允许你通过用一个装饰器类包裹对象，在运行时对一个对象动态添加行为\n\n#### 维基百科的解释\n\n在面向对象编程中，装饰器模式是一种设计模式，它允许将行为静态或动态地添加到单个对象中，而不会影响来自同一类的其他对象的行为。decorator模式对于遵循单一职责原则通常很有用，因为它允许在具有唯一关注区域的类之间划分功能。\n\n#### 优缺点\n\n**优点**\n\n-  你无需创建新子类即可扩展对象的行为。\n-  你可以在运行时添加或删除对象的功能。\n-  你可以用多个装饰封装对象来组合几种行为。\n-  *单一职责原则*。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。\n\n**缺点**\n\n-  在封装器栈中删除特定封装器比较困难。\n-  实现行为不受装饰栈顺序影响的装饰比较困难。\n-  各层的初始化配置代码看上去可能会很糟糕。\n\n#### typescript example\n\n下面时coffee例子的\n\n```typescript\ninterface Coffee {\n  getCost(): number\n  getDescription(): string\n}\n\nclass SimpleCoffee implements Coffee {\n  getCost() {\n    return 10\n  }\n  getDescription() {\n    return 'simple coffee'\n  }\n}\n\nclass MilkDecorator implements Coffee {\n  protected coffee: Coffee\n  protected description: string\n  constructor(c: Coffee) {\n    this.coffee = c\n    this.description = 'milk'\n  }\n  getCost() {\n    return 4 + this.coffee.getCost()\n  }\n  getDescription() {\n    return this.coffee.getDescription() + ' ' + this.description\n  }\n}\nclass WhipDecorator implements Coffee {\n  protected coffee: Coffee\n  protected description: string\n  constructor(c: Coffee) {\n    this.coffee = c\n    this.description = 'whip'\n  }\n  getCost() {\n    return 5 + this.coffee.getCost()\n  }\n  getDescription() {\n    return this.coffee.getDescription() + ' ' + this.description\n  }\n}\n// 香草\nclass VanillaDecorator implements Coffee {\n  protected coffee: Coffee\n  protected description: string\n  constructor(c: Coffee) {\n    this.coffee = c\n    this.description = 'vanilla'\n  }\n  getCost() {\n    return 3 + this.coffee.getCost()\n  }\n  getDescription() {\n    return this.coffee.getDescription() + ' ' + this.description\n  }\n}\n\nconst simpleCoffee = new SimpleCoffee()\nconsole.log(simpleCoffee.getDescription())\nconsole.log(simpleCoffee.getCost())\n\nconst milkCoffee = new MilkDecorator(simpleCoffee)\nconsole.log(milkCoffee.getDescription())\nconsole.log(milkCoffee.getCost())\n\nconst mixCoffee = new VanillaDecorator(\n  new MilkDecorator(new WhipDecorator(simpleCoffee))\n)\n\nconsole.log(mixCoffee.getDescription())\nconsole.log(mixCoffee.getCost())\nexport{}\n```\n\n### 2.🔌 适配器模式(Adapter)\n\n**亦称：** 封装器模式、Wrapper\n\n#### 现实的例子\n\n考虑到你的记忆卡中有一些图片，你需要把它们转移到你的电脑上。为了传输它们，你需要某种适配器，它与你的计算机端口兼容，这样你就可以把存储卡连接到你的计算机上。在这种情况下，读卡器是一个适配器。另一个例子是著名的电源适配器;三脚插头不能连接到两个尖头插座，它需要使用电源适配器，使其兼容两个尖头插座。还有一个例子是译者将一个人说的话翻译给另一个人\n\n#### 简单总结\n\n适配器模式允许您在适配器中包装其他不兼容的对象以使其与另一个类兼容。\n\n#### 维基百科的描述\n\n在软件工程中，适配器模式是一种软件设计模式，它允许将现有类的接口用作另一个接口。它通常用于使现有的类与其他类一起工作，而不修改它们的源代码。\n\n#### 优缺点\n\n**优点**\n\n-  _单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。\n-  *开闭原则*。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。\n\n**缺点**\n\n-  代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。\n\n#### typescript example\n\n想象一个猎人猎杀式子的游戏,现在我们加入狗,同时用适配器模式让猎人的猎人模块兼容狗\n\n```typescript\ninterface Lion {\n  roar(): void\n}\n\nclass AfricanLion implements Lion {\n  roar(): void {\n    console.log('aouuuuuuuu!')\n  }\n}\nclass AsianLion implements Lion {\n  roar(): void {\n    console.log('aooooooooooo!')\n  }\n}\n\nclass Hunter {\n  hunt(lion: Lion) {\n    lion.roar()\n  }\n}\n\nclass WildDog {\n  bark(): void {\n    console.log('wang!wang!wang!')\n  }\n}\n\nclass WildDogAdapter implements Lion {\n  protected dog\n  constructor(dog: WildDog) {\n    this.dog = dog\n  }\n  roar(): void {\n    this.dog.bark()\n  }\n}\n\nconst wildDog = new WildDog()\nconst wildDogAdapter = new WildDogAdapter(wildDog)\nconst hunter = new Hunter()\nhunter.hunt(wildDogAdapter)\n\n```\n\n### 3.📦 外观模式(Facade)\n\n**亦称：**门面模式\n\n#### 现实的例子\n\n(这台电脑怎么开机?)你会说“按电源按钮”!这就是你所相信的，因为你使用的是计算机提供的一个简单的界面，内部它需要做很多事情来实现它。这个到复杂子系统的简单接口就是facade。\n\n#### 简单总结\n\nFacade模式为复杂的子系统提供了简化的接口。\n\n#### 维基百科的描述\n\nfacade是一个对象，它为更大的代码体(如类库)提供了简化的接口。\n\n#### 优缺点\n\n**优点**\n\n- 你可以让自己的代码独立于复杂子系统。\n\n**缺点**\n\n-  外观可能成为与程序中所有类都耦合的[上帝对象](https://refactoringguru.cn/antipatterns/god-object)(指的是了解过多,或者负责过多的对象)。\n\n#### typescript example\n\n```typescript\nclass Computer {\n  // 断电\n  getElectricShock() {\n    console.log('Ouch')\n  }\n  makeSound() {\n    console.log('Beep beep!')\n  }\n  showLoadingScreen() {\n    console.log('Loading...')\n  }\n  bam() {\n    console.log('Ready to be used')\n  }\n  closeEverything() {\n    console.log('Bup bup bup buzzzz!')\n  }\n  sooth() {\n    console.log('Zzzzz')\n  }\n  pullCurrent() {\n    console.log('Haaah!')\n  }\n}\nclass ComputerFacade {\n  protected computer\n  constructor(computer: Computer) {\n    this.computer = computer\n  }\n  turnOn() {\n    this.computer.getElectricShock()\n    this.computer.makeSound()\n    this.computer.showLoadingScreen()\n    this.computer.bam()\n  }\n  turnOff() {\n    this.computer.closeEverything()\n    this.computer.pullCurrent()\n    this.computer.sooth()\n  }\n}\n\nconst computer = new ComputerFacade(new Computer())\ncomputer.turnOn()\ncomputer.turnOff()\n```\n\n### 4.🌿组合模式 (Composite)\n\n**亦称：** 对象树、Object Tree\n\n#### 现实的例子\n\n每个组织都是由员工组成的。每个员工都有相同的特征，比如有薪水，有一些职责，可能有也可能没有向某人汇报，可能有也可能没有下属等等。\n\n大部分国家的军队都采用层次结构管理。 每支部队包括几个师， 师由旅构成， 旅由团构成， 团可以继续划分为排。 最后， 每个排由一小队实实在在的士兵组成。 军事命令由最高层下达， 通过每个层级传递， 直到每位士兵都知道自己应该服从的命令。\n\n#### 简单总结\n\n**组合模式**是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n\n#### 维基百科的解释\n\n在软件工程中，组合模式是一种分区设计模式。组合模式描述了将一组对象作为对象的单个实例进行处理的方式。组合的目的是将对象“组合”成树结构，以表示部分-整体层次结构。实现组合模式让客户端能够统一对待单个对象和组合。\n\n#### 优缺点\n\n**优点**\n\n-  你可以利用多态和递归机制更方便地使用复杂树结构。\n-  *开闭原则*。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。\n\n**缺点**\n\n-  对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。\n\n#### typescript example\n\n```typescript\n/**\n * The base Component class declares common operations for both simple and\n * complex objects of a composition.\n */\nabstract class Component {\n  protected parent!: Component | null\n\n  /**\n   * Optionally, the base Component can declare an interface for setting and\n   * accessing a parent of the component in a tree structure. It can also\n   * provide some default implementation for these methods.\n   */\n  public setParent(parent: Component | null) {\n    this.parent = parent\n  }\n\n  public getParent(): Component | null {\n    return this.parent\n  }\n\n  /**\n   * In some cases, it would be beneficial to define the child-management\n   * operations right in the base Component class. This way, you won't need to\n   * expose any concrete component classes to the client code, even during the\n   * object tree assembly. The downside is that these methods will be empty\n   * for the leaf-level components.\n   */\n  public add(component: Component): void {}\n\n  public remove(component: Component): void {}\n\n  /**\n   * You can provide a method that lets the client code figure out whether a\n   * component can bear children.\n   */\n  public isComposite(): boolean {\n    return false\n  }\n\n  /**\n   * The base Component may implement some default behavior or leave it to\n   * concrete classes (by declaring the method containing the behavior as\n   * \"abstract\").\n   */\n  public abstract operation(): string\n}\n\n/**\n * The Leaf class represents the end objects of a composition. A leaf can't have\n * any children.\n *\n * Usually, it's the Leaf objects that do the actual work, whereas Composite\n * objects only delegate to their sub-components.\n */\nclass Leaf extends Component {\n  public operation(): string {\n    return 'Leaf'\n  }\n}\n\n/**\n * The Composite class represents the complex components that may have children.\n * Usually, the Composite objects delegate the actual work to their children and\n * then \"sum-up\" the result.\n */\nclass Composite extends Component {\n  protected children: Component[] = []\n\n  /**\n   * A composite object can add or remove other components (both simple or\n   * complex) to or from its child list.\n   */\n  public add(component: Component): void {\n    this.children.push(component)\n    component.setParent(this)\n  }\n\n  public remove(component: Component): void {\n    const componentIndex = this.children.indexOf(component)\n    this.children.splice(componentIndex, 1)\n\n    component.setParent(null)\n  }\n\n  public isComposite(): boolean {\n    return true\n  }\n\n  /**\n   * The Composite executes its primary logic in a particular way. It\n   * traverses recursively through all its children, collecting and summing\n   * their results. Since the composite's children pass these calls to their\n   * children and so forth, the whole object tree is traversed as a result.\n   */\n  public operation(): string {\n    const results = []\n    for (const child of this.children) {\n      results.push(child.operation())\n    }\n\n    return `Branch(${results.join('+')})`\n  }\n}\n\n/**\n * The client code works with all of the components via the base interface.\n */\nfunction clientCode(component: Component) {\n  // ...\n\n  console.log(`RESULT: ${component.operation()}`)\n\n  // ...\n}\n\n/**\n * This way the client code can support the simple leaf components...\n */\nconst simple = new Leaf()\nconsole.log(\"Client: I've got a simple component:\")\nclientCode(simple)\nconsole.log('')\n\n/**\n * ...as well as the complex composites.\n */\nconst tree = new Composite()\nconst branch1 = new Composite()\nbranch1.add(new Leaf())\nbranch1.add(new Leaf())\nconst branch2 = new Composite()\nbranch2.add(new Leaf())\ntree.add(branch1)\ntree.add(branch2)\nconsole.log(\"Client: Now I've got a composite tree:\")\nclientCode(tree)\nconsole.log('')\n\n/**\n * Thanks to the fact that the child-management operations are declared in the\n * base Component class, the client code can work with any component, simple or\n * complex, without depending on their concrete classes.\n */\nfunction clientCode2(component1: Component, component2: Component) {\n  // ...\n\n  if (component1.isComposite()) {\n    component1.add(component2)\n  }\n  console.log(`RESULT: ${component1.operation()}`)\n\n  // ...\n}\n\nconsole.log(\n  \"Client: I don't need to check the components classes even when managing the tree:\"\n)\nclientCode2(tree, simple)\n\n```\n\n### 5.🎱 代理模式(Proxy)\n\n#### 现实的例子\n\n你用过门禁卡进出一扇门吗?开门有多种选择，比如，可以使用门禁卡打开，也可以通过按下绕过安全的按钮打开。门的主要功能是打开，但在上面添加了一个代理来添加一些功能。让我用下面的代码示例更好地解释它。\n\n信用卡是银行账户的代理， 银行账户则是一大捆现金的代理。 它们都实现了同样的接口， 均可用于进行支付。 消费者会非常满意， 因为不必随身携带大量现金； 商店老板同样会十分高兴， 因为交易收入能以电子化的方式进入商店的银行账户中， 无需担心存款时出现现金丢失或被抢劫的情况。\n\n#### 简单总结\n\n**代理模式**是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。\n\n#### 优缺点\n\n**优点**\n\n-  你可以在客户端毫无察觉的情况下控制服务对象。\n-  如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。\n-  即使服务对象还未准备好或不存在， 代理也可以正常工作。\n-  *开闭原则*。 你可以在不对服务或客户端做出修改的情况下创建新代理。\n\n**缺点**\n\n- 代码可能会变得复杂， 因为需要新建许多类。\n-  服务响应可能会延迟。\n\n#### 与其他模式的联系\n\n- 适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。\n\n- 外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n\n- 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n#### typescript example\n\n```typescript\ninterface Door {\n  open(): void\n  close(): void\n}\n\nclass LabDoor implements Door {\n  open(): void {\n    console.log('opening the lab door')\n  }\n  close(): void {\n    console.log('closing the lab door')\n  }\n}\n\nclass SecuredDoor {\n  protected door: Door\n  protected password = '123456'\n  constructor(door: Door) {\n    this.door = door\n  }\n  open(password: string) {\n    if (this.authenticate(password)) {\n      this.door.open()\n    } else {\n      console.log('No,you cant open this door')\n    }\n  }\n\n  authenticate(passwords: string) {\n    return this.password == passwords\n  }\n  close() {\n    this.door.close()\n  }\n}\n\nconst door = new SecuredDoor(new LabDoor())\n\ndoor.open('1234567')\ndoor.open('123456')\ndoor.close()\n```\n\n### 6.🚡 桥接模式(Bridge)\n\n#### 现实的例子\n\n假设你有一个有不同页面的网站，你应该允许用户更改主题。你会怎么做?为每个主题创建每个页面的多个副本，还是只创建单独的主题并根据用户的偏好加载它们?桥牌模式允许你做后者，如下图\n\n![With and without the bridge pattern](assets/bridge-2abe760d08970fcef2f3eb211b40ca9a.png)\n\n\n\n假如你有一个几何 `形状`Shape类， 从它能扩展出两个子类：  `圆形`Circle和 `方形`Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为 `红色`Red和 `蓝色`Blue的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 `蓝色圆形`Blue­Circle和 `红色方形`Red­Square 。\n\n![桥接模式解决的问题](assets/bridge-problem-f3bb0dbe9d551b3aceb6172681b4e124.png)\n\n所有组合类的数量将以几何级数增长。\n\n在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。 如此以往， 情况会越来越糟糕。\n\n问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。 这在处理类继承时是很常见的问题。\n\n桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。\n\n![桥接模式的解决方案](assets/bridge-solution-c96115c7cb06311d8e5df8b133c306c7.png)\n\n将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。\n\n根据该方法， 我们可以将颜色相关的代码抽取到拥有 `红色`和 `蓝色`两个子类的颜色类中， 然后在 `形状`类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 `形状`和 `颜色`之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。\n#### 简单总结\n\n**桥接模式**是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。\n\n#### 优缺点\n\n**优点**\n\n- 你可以创建与平台无关的类和程序。\n-  客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。\n-  *开闭原则*。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。\n-  *单一职责原则*。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。\n\n**缺点**\n\n-  对高内聚的类使用该模式可能会让代码更加复杂。\n\n#### typescript example\n\n这里实现那个网页换主题的例子\n\n```typescript\nabstract class WebPage {\n  protected abstract theme: Theme\n\n  abstract getContent(): string\n}\n\nclass About extends WebPage {\n  protected theme: Theme\n  constructor(theme: Theme) {\n    super()\n    this.theme = theme\n  }\n  getContent(): string {\n    return `about page in ${this.theme.getColor()}`\n  }\n}\n\ninterface Theme {\n  getColor(): string\n}\n\nclass Careers extends WebPage {\n  protected theme: Theme\n  constructor(theme: Theme) {\n    super()\n    this.theme = theme\n  }\n  getContent() {\n    return `careers page in ${this.theme.getColor()}`\n  }\n}\n\nclass DarkTheme implements Theme {\n  getColor(): string {\n    return 'Dark Black'\n  }\n}\n\nclass LightTheme implements Theme {\n  getColor(): string {\n    return 'Off white'\n  }\n}\n\nclass AquaTheme implements Theme {\n  getColor(): string {\n    return 'Light blue'\n  }\n}\n\nconst darkTheme = new DarkTheme()\nconst about = new About(darkTheme)\nconst careers = new Careers(darkTheme)\nconsole.log(about.getContent())\nconsole.log(careers.getContent())\n\n```\n\n### 7.🍃享元模式(Flyweight)\n\n**亦称：** 缓存、Cache\n\n#### 现实的例子\n\n你在什么摊位上喝过新鲜的茶吗?他们通常会制作不止一个杯子，除了你使用的那个，剩下的留给其他客户，以节省资源。Flyweight模式就是关于资源共享的。\n\n#### 简单总结\n\n**享元模式**是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n\n#### 维基百科的解释\n\n在计算机编程中，flyweight是一种软件设计模式。flyweight是通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象;当一个简单的重复表示将使用不可接受的内存量时，它是一种大量使用对象的方法\n\n#### 优缺点\n\n**优点**\n\n-  如果程序中有很多相似对象， 那么你将可以节省大量内存。\n\n**缺点**\n\n- 你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。\n-  代码会变得更加复杂。 团队中的新成员总是会问：  “为什么要像这样拆分一个实体的状态？”。\n\n#### typescript example\n\n```typescript\nclass KaraTea {}\n\ninterface Tea {\n  [key: string]: KaraTea\n}\ninterface Order {\n  [key: number]: KaraTea\n}\nclass TeaMaker {\n  protected availableTea: Tea = {}\n  make(preference: string) {\n    if (!this.availableTea[preference]) {\n      this.availableTea[preference] = new KaraTea()\n    }\n    return this.availableTea[preference]\n  }\n}\n\nclass Teashop {\n  protected orders: Order = {}\n  protected teaMaker: TeaMaker\n  constructor(teaMaker: TeaMaker) {\n    this.teaMaker = teaMaker\n  }\n  takeOrder(teaType: string, table: number) {\n    this.orders[table] = this.teaMaker.make(teaType)\n  }\n  server() {\n    for (const key in this.orders) {\n      console.log(`Serving Tea to table#${key} `)\n    }\n  }\n}\n\nconst teaMaker = new TeaMaker()\nconst shop = new Teashop(teaMaker)\n\nshop.takeOrder('less sugar', 1)\nshop.takeOrder('more milk', 2)\nshop.takeOrder('without sugar', 5)\nshop.server()\n```\n\n\n\n\n## 行为设计模式\n\n行为设计模式涉及到对象之间的职责分配，和结构模式的不同之处在于，它不仅指定了结构，而且概述了消息传递的模式，换句话说，这有助于回答“如何在软件组织中运行一个行为”。\n\n这里介绍以下几种:\n\n- Chain of Responsibility\n- Command\n- Iterator\n- Mediator\n- Memento\n- Observer\n- Visitor\n- Strategy\n- State\n- Template Method\n\n### 1.💡策略模式(Strategy)\n\n#### 现实例子\n\n举一个排序的例子，我们首先实现了冒泡排序，但是随着数据量的增长我们发现冒泡排序的效率变得很慢，为此，我们又实现了快速排序处理大数据，但是这个快速排序处理小规模数据的效率比较低，所以为了处理这个问题，我们又实现了一个针对小规模数据的策略，使得在大规模数据上使用快速排序，小规模数据使用冒泡排序。\n\n#### 简单总结\n\n策略模式允许您根据情况切换算法或策略\n\n(实际上在js里面由于函数是一等公民，第一个参数设为函数，之后传入不同的排序函数就能达成类似的效果，也不需要用到多态)\n\n#### 优缺点\n\n**优点**\n\n-  你可以在运行时切换对象内的算法。\n-  你可以将算法的实现和使用算法的代码隔离开来。\n-  你可以使用组合来代替继承。\n-  *开闭原则*。 你无需对上下文进行修改就能够引入新的策略。\n\n**缺点**：\n\n-  如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。\n-  客户端必须知晓策略间的不同——它需要选择合适的策略。\n-  许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。\n\n#### typescript example\n\ntypescript 给JavaScript添加了更完善的面向对象支持，支持类型和interface\n\n下面是用typescript实现这个排序的例子的代码\n\n```typescript\ninterface SortStrategy {\n  sort(arr: Array<number>): Array<number>\n}\n\nclass BubbleSortStrategy implements SortStrategy {\n  sort(arr: number[]): number[] {\n    console.log('do bubble sort')\n    return arr\n  }\n}\n\nclass QuickSortStrategy implements SortStrategy {\n  sort(arr: number[]): number[] {\n    console.log('do quick sort')\n    return arr\n  }\n}\n\nclass Sorter {\n  sortStrategy: SortStrategy\n  constructor(sortStrategy: SortStrategy) {\n    this.sortStrategy = sortStrategy\n  }\n  sort(arr: Array<number>): Array<number> {\n    return this.sortStrategy.sort(arr)\n  }\n}\n\nnew Sorter(new BubbleSortStrategy()).sort([9, 2, 4, 3, 5])\nnew Sorter(new QuickSortStrategy()).sort([9, 2, 4, 3, 5])\n\n```\n\n实际上最后生成es5的代码，里面就没有接口了，\n\nJavaScript的多态和python一样，是通过鸭子类型实现的。\n\n```javascript\n\"use strict\";\nvar BubbleSortStrategy = /** @class */ (function () {\n    function BubbleSortStrategy() {\n    }\n    BubbleSortStrategy.prototype.sort = function (arr) {\n        console.log('do bubble sort');\n        return arr;\n    };\n    return BubbleSortStrategy;\n}());\nvar QuickSortStrategy = /** @class */ (function () {\n    function QuickSortStrategy() {\n    }\n    QuickSortStrategy.prototype.sort = function (arr) {\n        console.log('do quick sort');\n        return arr;\n    };\n    return QuickSortStrategy;\n}());\nvar Sorter = /** @class */ (function () {\n    function Sorter(sortStrategy) {\n        this.sortStrategy = sortStrategy;\n    }\n    Sorter.prototype.sort = function (arr) {\n        return this.sortStrategy.sort(arr);\n    };\n    return Sorter;\n}());\nnew Sorter(new BubbleSortStrategy()).sort([9, 2, 4, 3, 5]);\nnew Sorter(new QuickSortStrategy()).sort([9, 2, 4, 3, 5]);\n```\n\n下面是按照head first 设计模式，这本书第一个例子实现的鸭子模拟器代码。\n\n使用了策略模式，把给鸭子添加各种行为的代码抽离出来了，使得添加新的行为的代码改动比较小，并且可以动态改变行为。\n\n```typescript\ninterface FlyBehavior {\n  fly(): void\n}\nclass FlyWithWings implements FlyBehavior {\n  fly(): void {\n    console.log('i can fly')\n  }\n}\nclass FlyNoWay implements FlyBehavior {\n  fly(): void {\n    console.log('i can not fly')\n  }\n}\nclass FlyRocketPowered implements FlyBehavior {\n  fly(): void {\n    console.log('fly with a rocket!!!!!!!')\n  }\n}\n\ninterface QuackBehavior {\n  quack(): void\n}\nclass Quack implements QuackBehavior {\n  quack(): void {\n    console.log('quack!!!')\n  }\n}\n\nclass MuteQuack implements QuackBehavior {\n  quack(): void {\n    console.log('<<Silence>>')\n  }\n}\n\nabstract class Duck {\n  abstract flyBehavior: FlyBehavior\n  abstract quackBehavior: QuackBehavior\n  abstract display(): void\n  performFly(): void {\n    this.flyBehavior.fly()\n  }\n  performQuack(): void {\n    this.quackBehavior.quack()\n  }\n  swim(): void {\n    console.log('All ducks float,even decoys')\n  }\n}\nclass MallardDuck extends Duck {\n  flyBehavior: FlyBehavior = new FlyWithWings()\n  quackBehavior: QuackBehavior = new Quack()\n  display(): void {\n    console.log('this is MallarDuck')\n    this.performQuack()\n    this.performFly()\n    this.swim()\n  }\n}\n\nclass ModelDuck extends Duck {\n  flyBehavior: FlyBehavior = new FlyRocketPowered()\n  quackBehavior: QuackBehavior = new MuteQuack()\n  display(): void {\n    console.log('this is model duck')\n    this.performQuack()\n    this.performFly()\n    this.swim()\n  }\n}\n\nclass DuckCall extends Quack {}\n// const duck1 = new TestDuck()\n// duck1.performFly()\n// duck1.performQuack()\nnew MallardDuck().display()\nnew ModelDuck().display()\nnew DuckCall().quack()\n\n```\n\n\n\n#### golang example\n\ngo语言没有继承，go语言的interface也比较轻量，类似于python和js这样的鸭子类型了，只是多了类型检查而已，编译阶段找不到对应的函数就会报错了。\n\ngolang的interface只能包含函数，然后实现这个interface只要实现同样格式的函数就算实现接口。\n\n整体来说还是比较灵活的，比较简洁的。所以一个空接口interface{}所有类型都实现了它，可以用空接口接收所有类型。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype SortStrategyer interface {\n\tsort(list []int) []int\n}\n\ntype BubbleSortStrategy struct {\n}\n\nfunc (b *BubbleSortStrategy) sort(list []int) []int {\n\tfmt.Println(\"do bubble sort\")\n\treturn list\n}\n\ntype QuickSortStrategy struct {\n}\n\nfunc (b *QuickSortStrategy) sort(list []int) []int {\n\tfmt.Println(\"do quick sort\")\n\treturn list\n}\n\ntype Sorter struct {\n\tstrategy SortStrategyer\n}\n\nfunc (s *Sorter) doSort(list []int) []int {\n\treturn s.strategy.sort(list)\n}\n\nfunc main() {\n\ttestList := []int{4, 5, 3}\n\tsort1 := Sorter{strategy: &BubbleSortStrategy{}}\n\tsort1.doSort(testList)\n\tsort2 := Sorter{strategy: &QuickSortStrategy{}}\n\tsort2.doSort(testList)\n\tsort1.strategy = &QuickSortStrategy{}\n\tsort1.doSort(testList)\n}\n\n```\n\n#### dart example\n\ndart 是我用的几种编程语言中语法最接近java的。\n\ntypescript也很像java，但是它跟go一样把类型放在变量后面了。\n\ndart的不同之处在于，dart中没有像java一样的interface关键字，dart中每个类都可以当作接口，因此这里我们用了抽象类作为一个接口使用。\n\n```dart\nabstract class SortStrategy {\n  List<int> sort(List<int> data);\n}\n\nclass BubbleSortStrategy implements SortStrategy {\n  @override\n  List<int> sort(List<int> data) {\n    print('do bubble sort');\n    return data;\n  }\n}\n\nclass QuickSortStrategy implements SortStrategy {\n  @override\n  List<int> sort(List<int> data) {\n    print('do qucik sort');\n    return data;\n  }\n}\n\nclass Sorter {\n  final SortStrategy sortStrategy;\n// datr 构造函数语法糖，只需要在参数列表列出初始化参数，赋值自动帮你实现\n  Sorter(this.sortStrategy);\n\n  List<int> doSort(List<int> data) {\n    return this.sortStrategy.sort(data);\n  }\n}\n\nmain(List<String> args) {\n  var sort1 = Sorter(BubbleSortStrategy());\n  sort1.doSort([1, 2, 3]);\n  var sort2 = Sorter(QuickSortStrategy());\n  sort2.doSort([1, 2, 3]);\n}\n\n```\n\n\n\n### 2.😎观察者模式(Observer)\n\n#### 现实例子\n\n也叫做发布订阅模式,这里给出的例子是,求职者订阅了招聘网站的服务,如果有匹配的工作信息,招聘网站会进行推送\n\n\n\n#### 简单总结\n\n建立对象间的依赖关系，使得一个对象的状态发生改变时，所有依赖它的对象都能被通知到。\n\n\n\n#### 维基百科的描述\n\n观察者模式是一种软件设计模式，在这种模式中，一个称为主体的对象维护一个称为观察者的依赖项列表，并在任何状态更改时自动通知它们(通常通过调用它们的一个方法)。\n\n#### 优缺点\n\n**优点**\n\n-  *开闭原则*。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。\n-  你可以在运行时建立对象之间的联系。\n\n#### typescript example\n\n\n\n```typescript\ninterface Subject {\n  registerObserver(o: Observer): void\n  removeObserver(o: Observer): void\n  notifyObservers(info: any): void\n}\n\ninterface Observer {\n  update(s: Subject, arg: Object): void\n}\n\nclass JobInfo {\n  protected info: string\n  constructor(info: string) {\n    this.info = info\n  }\n  getInfo() {\n    return this.info\n  }\n}\n\nclass JobSite implements Subject {\n  protected observers: Array<Observer>\n  constructor() {\n    this.observers = Array<Observer>()\n  }\n  registerObserver(o: Observer): void {\n    this.observers.push(o)\n  }\n  removeObserver(o: Observer): void {\n    const index = this.observers.indexOf(o)\n    this.observers.splice(index, 1)\n  }\n  notifyObservers(info: JobInfo): void {\n    for (const o of this.observers) {\n      o.update(this, info)\n    }\n  }\n\n  AddJob(info: JobInfo) {\n    console.log('招聘网站有新的工作追加了')\n\n    this.notifyObservers(info)\n  }\n}\n\nclass Jiucai implements Observer {\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n  update(s: Subject, arg: JobInfo): void {\n    console.log(`${this.name}收到新工作推送，职位是${arg.getInfo()}`)\n  }\n}\n\nconst zibenjia = new JobSite()\n\nconst jiucai1 = new Jiucai('生命1号')\nconst jiucai2 = new Jiucai('脑白金')\n\nzibenjia.registerObserver(jiucai1)\nzibenjia.registerObserver(jiucai2)\n\nzibenjia.AddJob(new JobInfo('web前端'))\nzibenjia.AddJob(new JobInfo('算法工程师'))\n\n```\n\n下面是head first设计模式这本书里面关于气象站和告示板的typescript代码实现\n\n```typescript\ninterface Subject {\n  registerObserver(o: Observer): void\n  removeObserver(o: Observer): void\n  notifyObservers(): void\n}\n\ninterface Observer {\n  update(temp: number, humidity: number, pressure: number): void\n}\n\ninterface DisplayElement {\n  display(): void\n}\n\nclass WeatherData implements Subject {\n  private observers: Array<Observer>\n  private temperature!: number\n  private humidity!: number\n  private pressure!: number\n  constructor() {\n    this.observers = Array<Observer>()\n  }\n  registerObserver(o: Observer): void {\n    this.observers.push(o)\n  }\n  removeObserver(o: Observer): void {\n    const index = this.observers.indexOf(o)\n    this.observers.splice(index, 1)\n  }\n  notifyObservers(): void {\n    for (const o of this.observers) {\n      o.update(this.temperature, this.humidity, this.pressure)\n    }\n  }\n\n  measurementsChanged() {\n    this.notifyObservers()\n  }\n  setMeasurements(temperature: number, humidity: number, pressure: number) {\n    this.temperature = temperature\n    this.humidity = humidity\n    this.pressure = pressure\n    this.measurementsChanged()\n  }\n}\n\nclass CurrentConditionDisplay implements Observer, DisplayElement {\n  private temperature!: number\n  private humidity!: number\n  private weatherData: Subject\n  constructor(weatherData: Subject) {\n    this.weatherData = weatherData\n    this.weatherData.registerObserver(this)\n  }\n  update(temp: number, humidity: number, pressure: number): void {\n    this.temperature = temp\n    this.humidity = humidity\n    this.display()\n  }\n\n  display(): void {\n    console.log(\n      `Current conditionsc: ${this.temperature} F degrees and ${this.humidity}% humidity`\n    )\n  }\n}\n\nclass StatisticsConditionDisplay implements Observer, DisplayElement {\n  private pressure!: number\n  private weatherData: Subject\n  constructor(weatherData: Subject) {\n    this.weatherData = weatherData\n    this.weatherData.registerObserver(this)\n  }\n  update(temp: number, humidity: number, pressure: number): void {\n    this.pressure = pressure\n    this.display()\n  }\n\n  display(): void {\n    console.log(`Statistics conditionsc: ${this.pressure} pressure`)\n  }\n}\nconst wd = new WeatherData()\nconst ccd = new CurrentConditionDisplay(wd)\nconst scd = new StatisticsConditionDisplay(wd)\nwd.setMeasurements(80, 65, 30.4)\nwd.setMeasurements(82, 75, 28.3)\nwd.setMeasurements(78, 90, 36.4)\n\nexport {}\n\n```\n\n\n\n\n\n#### dart example\n\ndart中Object不想typescript一样可以接受任何其他类。\n\n所以我这里对observer 用了泛型。\n\n```dart\nabstract class Observer<T> {\n  void update(Subject s, T o);\n}\n\nabstract class Subject {\n  void registerObserver(Observer o);\n  void removeObserver(Observer o);\n  void notifyObservers(Object o);\n}\n\nclass JobInfo {\n  late String info;\n  JobInfo(this.info);\n}\n\nclass JobSite implements Subject {\n  final List<Observer> observers = [];\n\n  @override\n  void registerObserver(Observer o) {\n    this.observers.add(o);\n  }\n\n  @override\n  void removeObserver(Observer o) {\n    this.observers.remove(o);\n  }\n\n  @override\n  void notifyObservers(Object o) {\n    for (var item in this.observers) {\n      item.update(this, o);\n    }\n  }\n\n  void addJobInfo(JobInfo j) {\n    print('有新的工作信息');\n    this.notifyObservers(j);\n  }\n}\n\nclass Jiucai implements Observer<JobInfo> {\n  final String name;\n\n  Jiucai(this.name);\n  @override\n  void update(Subject s, JobInfo o) {\n    print(\"$name收到新的工作推送，职位是${o.info}\");\n  }\n}\n\nmain(List<String> args) {\n  var zibenjia = JobSite();\n\n  var jiucai1 = Jiucai('李白');\n  var jiucai2 = Jiucai('白居易');\n\n  zibenjia.registerObserver(jiucai1);\n  zibenjia.registerObserver(jiucai2);\n  zibenjia.addJobInfo(JobInfo('AI工程师'));\n}\n\n```\n\n#### golang example\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Subject interface {\n\tregisterObserver(o Observer)\n\tremoveObserver(o Observer)\n\tnotifyObservers(s Subject, o interface{})\n}\n\ntype Observer interface {\n\tupdate(s Subject, o interface{})\n}\n\ntype JobSite struct {\n\tobservers []Observer\n}\n\nfunc (j *JobSite) registerObserver(o Observer) {\n\tj.observers = append(j.observers, o)\n}\n\nfunc (j *JobSite) removeObserver(o Observer) {\n\tfor i := 0; i < len(j.observers); i++ {\n\t\tif o == j.observers[i] {\n\t\t\tj.observers = append(j.observers[:i], j.observers[i+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n}\nfunc (j *JobSite) notifyObservers(s Subject, o interface{}) {\n\tfor i := 0; i < len(j.observers); i++ {\n\t\tj.observers[i].update(s, o)\n\t}\n}\nfunc (j *JobSite) addJobInfo(info string) {\n\tfmt.Println(\"新工作信息入库\")\n\tj.notifyObservers(j, info)\n}\n\ntype Jiucai struct {\n\tname string\n}\n\nfunc (j *Jiucai) update(s Subject, o interface{}) {\n\tfmt.Printf(\"%s收到新的工作推送，职位是%v\\n\", j.name, o)\n}\nfunc main() {\n\tzibenjia := JobSite{observers: []Observer{}}\n\tjiucai1 := Jiucai{name: \"张三\"}\n\tjiucai2 := Jiucai{name: \"李四\"}\n\tzibenjia.registerObserver(&jiucai1)\n\tzibenjia.registerObserver(&jiucai2)\n\tzibenjia.addJobInfo(\"喝牛奶\")\n\n}\n\n```\n\n\n\n### 3.👮命令模式(Command)\n\n**亦称：** 动作、事务、Action、Transaction\n\n#### 真实世界的例子\n\n一个例子是餐馆点餐， 您（即客户）询问服务员（即，调用者）携带一些食物（即命令）和服务员只需将该请求转发给厨师（即接收者），该请求具有关于烹饪的内容和如何烹饪的知识。 另一个例子是您（即客户端）使用遥控器（即，Command）的电视（即，接收器）打开（即，接收器）。\n\n#### 简单总结\n\n允许您在对象中封装动作。此模式背后的关键思想是提供分离客户机与接收者的方法。\n\n#### 维基百科的解释\n\n在面向对象编程中，命令模式是一种行为设计模式，在这种模式中，一个对象被用来封装在以后执行一个动作或触发一个事件所需的所有信息。该信息包括方法名、拥有该方法的对象和方法参数的值。\n\n#### 优缺点\n\n**优点**\n\n- *单一职责原则*。 你可以解耦触发和执行操作的类。\n-  *开闭原则*。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。\n-  你可以实现撤销和恢复功能。\n-  你可以实现操作的延迟执行。\n-  你可以将一组简单命令组合成一个复杂命令。\n\n**缺点**\n\n-  代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。\n\n#### typescript example\n\n下面是一个遥控器控制灯泡开关的实现。\n\n```typescript\n// 灯泡\nclass Bulb {\n  turnOn() {\n    console.log('Bulb has been lit')\n  }\n  turnOff() {\n    console.log('be dark')\n  }\n}\n\ninterface Command {\n  execute(): void\n  undo(): void\n  redo(): void\n}\n\nclass TurnOn implements Command {\n  protected bulb: Bulb\n  constructor(bulb: Bulb) {\n    this.bulb = bulb\n  }\n  execute(): void {\n    this.bulb.turnOn()\n  }\n  undo(): void {\n    this.bulb.turnOff()\n  }\n  redo(): void {\n    this.execute()\n  }\n}\nclass TurnOff implements Command {\n  protected bulb: Bulb\n  constructor(bulb: Bulb) {\n    this.bulb = bulb\n  }\n  execute(): void {\n    this.bulb.turnOff()\n  }\n  undo(): void {\n    this.bulb.turnOn()\n  }\n  redo(): void {\n    this.execute()\n  }\n}\n\nclass RemoteControl {\n  submit(command: Command) {\n    command.execute()\n  }\n}\n\nconst bulb = new Bulb()\n\nconst turnOn = new TurnOn(bulb)\nconst turnOff = new TurnOff(bulb)\n\nconst remote = new RemoteControl()\nremote.submit(turnOn)\nremote.submit(turnOff)\n\n```\n\n### 4.📒 模板方法(Template Method)\n\n#### 真实世界的例子\n\n假设我们要建房子。建造的步骤可能像这样\n\n- 准备好房子的地基\n\n- 构建墙\n\n- 添加屋顶\n\n- 添加其他楼层\n\n这些步骤的顺序永远不会改变，例如，你不能在建造墙壁之前建造屋顶，但每个步骤都可以修改，例如，墙壁可以由木材、聚酯或石头制成。\n\n#### 简单总结\n\n模板方法定义了如何执行某个算法的框架，但将这些步骤的实现推迟到子类。\n\n#### 维基百科的描述\n\n在软件工程中，模板方法模式是一种行为设计模式，它在操作中定义算法的程序框架，将一些步骤推迟到子类中。它允许人们在不改变算法结构的情况下重新定义算法的某些步骤。\n\n#### 优缺点\n\n**优点**\n\n-  你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。\n-  你可将重复代码提取到一个超类中。\n\n**缺点**\n\n-  部分客户端可能会受到算法框架的限制。\n-  通过子类抑制默认步骤实现可能会导致违反_里氏替换原则_(即派生类可以在程序中替换基类对象)。\n-  模板方法中的步骤越多， 其维护工作就可能会越困难。\n\n#### typescript example\n\n假设我们有一个构建工具，可以帮助我们测试、lint、构建、生成构建报告(即代码覆盖报告、linting报告等)，并将我们的应用部署到测试服务器上。首先，我们有为构建算法指定骨架的基类\n\n```typescript\nabstract class Builder {\n  build() {\n    this.test()\n    this.lint()\n    this.assemble()\n    this.deploy()\n  }\n  abstract test(): void\n  abstract lint(): void\n  abstract assemble(): void\n  abstract deploy(): void\n}\n\nclass AndroidBuilder extends Builder {\n  test(): void {\n    console.log('Running android test')\n  }\n  lint(): void {\n    console.log('Linting the android code.')\n  }\n  assemble(): void {\n    console.log('Assembling the andorid build.')\n  }\n  deploy(): void {\n    console.log('Deploying android build to server')\n  }\n}\n\nclass IosBuilder extends Builder {\n  test(): void {\n    console.log('Running ios test')\n  }\n  lint(): void {\n    console.log('Linting the ios code.')\n  }\n  assemble(): void {\n    console.log('Assembling the ios build.')\n  }\n  deploy(): void {\n    console.log('Deploying ios build to server')\n  }\n}\n\nconst androidBuilder = new AndroidBuilder()\nandroidBuilder.build()\nconst iosBuilder = new IosBuilder()\niosBuilder.build()\n\n```\n\n### 5.➿迭代器模式 (Iterator)\n\n#### 现实的例子\n\n一个旧的收音机将是迭代器的一个很好的例子，用户可以从某个拼搭开始，然后使用下一个或上一个按钮通过相应的通道。或者以MP3播放器或电视机为例，你可以按下一个和上一个按钮来浏览连续的频道，或者换句话说，它们都提供了一个界面来迭代各个频道、歌曲或电台。\n\n又比如说列表和数组的遍历方式不同,你可以用迭代器模式把他们封装成一致的使用方式.\n\n#### 简单总结\n\n**迭代器模式**是一种行为设计模式 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n\n#### 维基百科的解释\n\n在面向对象编程中，迭代器模式是一种设计模式，其中迭代器用于遍历容器并访问容器的元素。迭代器模式将算法与容器解耦;在某些情况下，算法必须是特定于容器的，因此不能解耦。\n\n#### 优缺点\n\n**优点**\n\n-  *单一职责原则*。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。\n-  *开闭原则*。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。\n-  你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。\n-  相似的， 你可以暂停遍历并在需要时继续。\n\n**缺点**\n\n-  如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。\n-  对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。\n\n#### typescript example\n\n```typescript\n/**\n * Iterator Design Pattern\n *\n * Intent: Lets you traverse elements of a collection without exposing its\n * underlying representation (list, stack, tree, etc.).\n */\n\ninterface Iterator<T> {\n  // Return the current element.\n  current(): T\n\n  // Return the current element and move forward to next element.\n  next(): T\n\n  // Return the key of the current element.\n  key(): number\n\n  // Checks if current position is valid.\n  valid(): boolean\n\n  // Rewind the Iterator to the first element.\n  rewind(): void\n}\n\ninterface Aggregator {\n  // Retrieve an external iterator.\n  getIterator(): Iterator<string>\n}\n\n/**\n * Concrete Iterators implement various traversal algorithms. These classes\n * store the current traversal position at all times.\n */\n\nclass AlphabeticalOrderIterator implements Iterator<string> {\n  private collection: WordsCollection\n\n  /**\n   * Stores the current traversal position. An iterator may have a lot of\n   * other fields for storing iteration state, especially when it is supposed\n   * to work with a particular kind of collection.\n   */\n  private position: number = 0\n\n  /**\n   * This variable indicates the traversal direction.\n   */\n  private reverse: boolean = false\n\n  constructor(collection: WordsCollection, reverse: boolean = false) {\n    this.collection = collection\n    this.reverse = reverse\n\n    if (reverse) {\n      this.position = collection.getCount() - 1\n    }\n  }\n\n  public rewind() {\n    this.position = this.reverse ? this.collection.getCount() - 1 : 0\n  }\n\n  public current(): string {\n    return this.collection.getItems()[this.position]\n  }\n\n  public key(): number {\n    return this.position\n  }\n\n  public next(): string {\n    const item = this.collection.getItems()[this.position]\n    this.position += this.reverse ? -1 : 1\n    return item\n  }\n\n  public valid(): boolean {\n    if (this.reverse) {\n      return this.position >= 0\n    }\n\n    return this.position < this.collection.getCount()\n  }\n}\n\n/**\n * Concrete Collections provide one or several methods for retrieving fresh\n * iterator instances, compatible with the collection class.\n */\nclass WordsCollection implements Aggregator {\n  private items: string[] = []\n\n  public getItems(): string[] {\n    return this.items\n  }\n\n  public getCount(): number {\n    return this.items.length\n  }\n\n  public addItem(item: string): void {\n    this.items.push(item)\n  }\n\n  public getIterator(): Iterator<string> {\n    return new AlphabeticalOrderIterator(this)\n  }\n\n  public getReverseIterator(): Iterator<string> {\n    return new AlphabeticalOrderIterator(this, true)\n  }\n}\n\n/**\n * The client code may or may not know about the Concrete Iterator or Collection\n * classes, depending on the level of indirection you want to keep in your\n * program.\n */\nconst collection = new WordsCollection()\ncollection.addItem('First')\ncollection.addItem('Second')\ncollection.addItem('Third')\n\nconst iterator = collection.getIterator()\n\nconsole.log('Straight traversal:')\nwhile (iterator.valid()) {\n  console.log(iterator.next())\n}\n\nconsole.log('')\nconsole.log('Reverse traversal:')\nconst reverseIterator = collection.getReverseIterator()\nwhile (reverseIterator.valid()) {\n  console.log(reverseIterator.next())\n}\n```\n\n### 6.💢 状态模式(State)\n\n#### 现实的例子\n\n假设您正在使用一些绘图应用程序，您选择画笔进行绘制。现在笔刷会根据选择的颜色改变它的行为，例如，如果你选择了红色，它就会以红色绘制，如果是蓝色，它就会以蓝色绘制，等等。\n\n智能手机的按键和开关会根据设备当前状态完成不同行为：\n\n- 当手机处于解锁状态时， 按下按键将执行各种功能。\n- 当手机处于锁定状态时， 按下任何按键都将解锁屏幕。\n- 当手机电量不足时， 按下任何按键都将显示充电页面。\n\n#### 简单总结\n\n**状态模式**是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n\n#### 维基百科的解释\n\n状态模式是一种行为软件设计模式，其以面向对象方式实现状态机。 利用状态模式，通过将每个单独的状态作为状态模式接口的派生类实现每个单独的状态来实现状态机，并通过调用由模式的超类定义的方法来实现状态转换。 状态模式可以被解释为能够通过模式接口中定义的方法的调用来切换当前策略的策略模式。\n\n#### 优缺点\n\n**优点**\n\n-  *单一职责原则*。 将与特定状态相关的代码放在单独的类中。\n-  *开闭原则*。 无需修改已有状态类和上下文就能引入新状态。\n-  通过消除臃肿的状态机条件语句简化上下文代码。\n\n**缺点**\n\n-  如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。\n\n#### 与其他模式的关系\n\n- **桥接模式**、 **状态模式**和**策略模式** （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n\n- 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n#### typescript example\n\n让我们举一个文本编辑器的例子，它可以让你改变输入的文本的状态，例如，如果你选择了粗体，它就开始写粗体，如果是斜体，然后是斜体等等。\n\n```typescript\ninterface WritingState {\n  write(words: string): void\n}\n\nclass UpperCase implements WritingState {\n  write(words: string): void {\n    console.log(`Uppercase:${words}`)\n  }\n}\n\nclass LowerCase implements WritingState {\n  write(words: string): void {\n    console.log(`Lowercase:${words}`)\n  }\n}\n\nclass DefaultText implements WritingState {\n  write(words: string): void {\n    console.log(`DefaultText:${words}`)\n  }\n}\n\nclass TextEditor {\n  protected state: WritingState\n  constructor(state: WritingState) {\n    this.state = state\n  }\n  setState(state: WritingState) {\n    this.state = state\n  }\n  type(words: string) {\n    this.state.write(words)\n  }\n}\n\nconst editor = new TextEditor(new DefaultText())\neditor.type('hello')\neditor.setState(new UpperCase())\neditor.type('1')\n\neditor.setState(new LowerCase())\n\neditor.type('2')\n\n```\n\n\n\n### 7.🔗责任链模式 Chain of Responsibility\n\n#### 现实的例子\n\n例如，您在您的帐户中设置了三个付款方式（A，B和C）设置; 每个都有不同的量。 A有100美元，B有300美元，C具有1000美元，你偏好的购买顺序是先A后B后C.您尝试购买价值210美元的东西。 使用责任链，首先将检查它是否可以购买购买，如果是购买，则将进行购买，并且链将被打破。 如果没有，请求将前进以向帐户B检查金额如果是链将被打破，否则请求将继续转发，直到它找到合适的处理程序。 这里，B和C是链条的链接，整个现象是责任链。\n\n#### 简单总结\n\n**责任链模式**是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n\n#### 优缺点\n\n**优点**\n\n-  你可以控制请求处理的顺序。\n-  *单一职责原则*。 你可对发起操作和执行操作的类进行解耦。\n-  *开闭原则*。 你可以在不更改现有代码的情况下在程序中新增处理者。\n\n**缺点**\n\n-  部分请求可能未被处理。\n\n#### typescript example\n\n```typescript\nabstract class Account {\n  protected successor: Account | null = null\n  protected abstract balance: number\n  setNext(account: Account) {\n    this.successor = account\n  }\n  pay(amountToPay: number) {\n    if (this.canPay(amountToPay)) {\n      console.log(`paid ${amountToPay} using ${this.constructor.toString()}`)\n    } else if (this.successor) {\n      console.log('cant pay ,using next...')\n      this.successor.pay(amountToPay)\n    } else {\n      throw new Error('None of the accounts have enough balance')\n    }\n  }\n  canPay(amount: number): boolean {\n    return this.balance >= amount\n  }\n}\n\nclass Bank extends Account {\n  protected balance: number\n  constructor(balance: number) {\n    super()\n    this.balance = balance\n  }\n}\n\nclass Paypal extends Account {\n  protected balance: number\n  constructor(balance: number) {\n    super()\n    this.balance = balance\n  }\n}\n\nclass Bitcoin extends Account {\n  protected balance: number\n  constructor(balance: number) {\n    super()\n    this.balance = balance\n  }\n}\n\nconst bank = new Bank(100)\nconst paypal = new Paypal(200)\nconst bitcoin = new Bitcoin(300)\n\nbank.setNext(paypal)\npaypal.setNext(bitcoin)\nbank.pay(259)\n```\n\n### 8.👽中介者模式(Mediator)\n\n**亦称：** 调解人、控制器、Intermediary、Controller\n\n#### 现实的例子\n\n一个一般的例子是，当你用手机和某人交谈时，有一个网络提供商坐在你和他们之间，你的谈话经过它而不是直接发送。在这种情况下，网络提供者是中介。\n\n#### 简单总结\n\n**中介者模式**是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n\n#### 优缺点\n\n**优点**\n\n- *单一职责原则*。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。\n-  *开闭原则*。 你无需修改实际组件就能增加新的中介者。\n-  你可以减轻应用中多个组件间的耦合情况。\n-  你可以更方便地复用各个组件。\n\n**缺点**\n\n一段时间后， 中介者可能会演化成为 **上帝对象**（中介者本身会过于复杂）。\n\n#### typescript example\n\n```typescript\ninterface ChatRoomMediator {\n  showMessage(user: User, message: string): void\n}\n\nclass ChatRoom implements ChatRoomMediator {\n  showMessage(user: User, message: string): void {\n    const time = new Date().toUTCString()\n    const sender = user.getName()\n    console.log(`${time}[${sender}]:${message}`)\n  }\n}\n\nclass User {\n  protected name: string\n  protected chatMediator: ChatRoomMediator\n  constructor(name: string, chatMediator: ChatRoomMediator) {\n    this.name = name\n    this.chatMediator = chatMediator\n  }\n  getName() {\n    return this.name\n  }\n  send(message: string) {\n    this.chatMediator.showMessage(this, message)\n  }\n}\n\nconst mediator = new ChatRoom()\n\nconst john = new User('John Doe', mediator)\nconst jane = new User('Jane Doe', mediator)\n\njohn.send('hi,its me')\njane.send('hey!')\n```\n\n### 9.💾备忘录模式(Memento)\n\n**亦称：** 快照、Snapshot\n\n#### 现实的例子\n\n以计算器为例，无论何时你执行一些计算，最后的计算都会保存在内存中，这样你就可以使用某些操作按钮返回计算器并恢复它。\n\n#### 简单总结\n\n**备忘录模式**是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n\n#### 适合的使用场景\n\n 当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n\n 备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。\n\n 当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n\n 备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。\n\n#### 优缺点\n\n**优点**\n\n-  你可以在不破坏对象封装情况的前提下创建对象状态快照。\n-  你可以通过让负责人维护原发器状态历史记录来简化原发器代码。\n\n**缺点**\n\n-  如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。\n-  负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。\n-  绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。\n\n#### typescript example\n\n```typescript\nclass EditorMemento {\n  protected content: string\n  constructor(content: string) {\n    this.content = content\n  }\n  getContent() {\n    return this.content\n  }\n}\n\nclass Editor {\n  protected content = ''\n  type(words: string) {\n    this.content = this.content + words\n  }\n  getContent() {\n    return this.content\n  }\n  save() {\n    return new EditorMemento(this.content)\n  }\n  restore(memento: EditorMemento) {\n    this.content = memento.getContent()\n  }\n}\n\nconst editor = new Editor()\neditor.type('first sentence\\n')\neditor.type('this is second\\n')\nconst saved = editor.save()\n\neditor.type('third\\n')\nconsole.log(editor.getContent())\neditor.restore(saved)\nconsole.log(editor.getContent())\n\nexport {}\n\n```\n\n### 10.🏃访问者模式(Visitor)\n\n#### 现实的例子\n\n考虑一下去迪拜旅游的人。他们只需要一种方式(即签证)进入迪拜。到达后，他们可以自己来参观迪拜的任何地方，而不需要申请许可或行走一大段距离来参观这里的任何地方;只要让他们知道一个地方，他们就可以去参观。访客模式可以让你做到这一点，它可以帮助你添加要参观的地方，这样他们可以尽可能多地参观，而不必做任何跑腿的工作\n\n#### 简单总结\n\n**访问者模式**是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n\n#### 优缺点\n\n**优点**\n\n- *开闭原则*。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。\n-  *单一职责原则*。 可将同一行为的不同版本移到同一个类中。\n-  访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。\n\n**缺点**\n\n-  每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。\n-  在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。\n\n#### typescript example\n\n```typescript\ninterface Animal {\n  accept(operation: AnimalOperation): void\n}\n\ninterface AnimalOperation {\n  visitMonkey(monkey: Monkey): void\n  visitLion(lion: Lion): void\n  visitDolphin(dolphin: Dolphin): void\n}\n\nclass Monkey implements Animal {\n  shout() {\n    console.log('Ooh oo aa aa!')\n  }\n  accept(operation: AnimalOperation) {\n    operation.visitMonkey(this)\n  }\n}\n\nclass Lion implements Animal {\n  accept(operation: AnimalOperation): void {\n    operation.visitLion(this)\n  }\n  roar() {\n    console.log('Roaaar!')\n  }\n}\nclass Dolphin implements Animal {\n  accept(operation: AnimalOperation): void {\n    operation.visitDolphin(this)\n  }\n  speak() {\n    console.log('Tuut tuttu tuutt')\n  }\n}\n\nclass Speak implements AnimalOperation {\n  visitMonkey(monkey: Monkey): void {\n    monkey.shout()\n  }\n  visitLion(lion: Lion): void {\n    lion.roar()\n  }\n  visitDolphin(dolphin: Dolphin): void {\n    dolphin.speak()\n  }\n}\n\nconst monkey = new Monkey()\nconst lion = new Lion()\nconst dolphin = new Dolphin()\nconst speak = new Speak()\nmonkey.accept(speak)\nlion.accept(speak)\ndolphin.accept(speak)\nexport {}\n```\n\n"}},"__N_SSG":true}