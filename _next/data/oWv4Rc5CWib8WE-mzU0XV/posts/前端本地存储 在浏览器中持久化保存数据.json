{"pageProps":{"postData":{"id":"前端本地存储 在浏览器中持久化保存数据","title":"4种前端本地存储方法 在浏览器中持久化保存数据","date":"2020-01-01","content":"\n\n# 4种前端本地存储方法 在浏览器中持久化保存数据\n\n\n\n常见的4种前端存储数据的方式是cookie,LocalStorage,session sorage,IndexedDB\n\n其中sessionStorage有时效性,仅在当前会话有效,当前会话结束后就会删除.\n\n所以实质上,用于长期存储的方式只有3种,\n\n下面放出他们进行对比的表格\n\n其中indexDB相当于本地数据库,所以单独拿出来说\n\n| 对比项目       | cookie         | localstorage | sessionStorage |\n| -------------- | -------------- | ------------ | -------------- |\n| 数据存储时间   | 可设置失效时间 | 永久         | 仅当前会话     |\n| 容量           | <=4kb          | <=5mb        | <=5mb          |\n\n其中三种方式都有原生api,其中cookie的原生api比较难用,cookie还有一个特点是会随着请求携带,并且可以被服务端随意修改\n\n\n\n因此得出结论,一般网页应用用localstorage就行了,5mb存储一个应用的配置信息还是挺宽裕的.\n\n另外会话中临时会使用的信息就用sessionStorage\n\n\n\n## cookie\n\ncookie的主要属性表格\n\n| key      | value                                                        |\n| -------- | ------------------------------------------------------------ |\n| Name     | cookie的名称                                                 |\n| Value    | cookie的值,最大容量4Kb                                       |\n| Domain   | cookie存储的域名                                             |\n| Path     | cookie存储的路径                                             |\n| Size     | cookie的大小                                                 |\n| Expires  | 过期时间,值可以是UTC格式,可以使用 Date.prototype.toUTCString() 进行转换 |\n| Max-Age  | 优先级高于Expires,设置cookie存活的秒数                       |\n| HttpOnly | 安全性,设置这个属性后,cookie就不会被js获取到,只有在发起请求时会带上 |\n| Secure   | 不需要设置,当协议是https时,自动开启,指定浏览器只有在加密协议 HTTPS 下才能发送cookie\\ |\n| SameSite | 跨站策略,设置为Lax,即仅允许同站或子站访问cookie;None:允许所有跨站cookie,设置为Lax会导致第三方cookie失效 |\n\ncookie的原生api还是比较不人性化的,需要拼接字符串.所以一般我们会进行封装\n\n下面是原生api的封装\n\n### 设置cookie\n\n```javascript\n/**\n * 设置cookie\n * @param {*} key 名称\n * @param {*} val 值\n * @param {*} time 失效时间\n */\n\nexport const setCookie = (key, val, expiresDays) => {\n\n  var date = new Date();\n\n  //将时间转换为cookie设置时间的格式\n\n  date.setTime(date.getTime() + expiresDays * 24 * 3600 * 1000);\n\n  document.cookie = key + \"=\" + val + \";expires=\" + date.toDateString();\n}\n```\n\n### 获取cookie\n\n```javascript\n/**\n * 获取cookie\n * @param {*} key 名称\n */\n\nexport const getCookie = (key) => {\n\n  var getCookie = document.cookie.replace(/[ ]/g, \"\");\n\n  var arrCookie = getCookie.split(\";\")\n\n  var tips;\n\n  for (var i = 0; i < arrCookie.length; i++) {\n\n    var arr = arrCookie[i].split(\"=\");\n\n    if (key == arr[0]) {\n\n      tips = arr[1];\n\n      break;\n\n    }\n\n  }\n\n  return tips;\n\n}\n```\n\n### 删除cookie\n\n可以直接调用setCookie,把cookie的失效时间设置为-1即可\n\n```javascript\nsetCookie(key,'',-1)\n```\n\n### 利用第三方cookie追踪用户\n\ncookie执行同源策略\n\n同源的定义为:如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是*同源*。\n\n下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例:\n\n| URL                                               | 结果 | 原因                               |\n| :------------------------------------------------ | :--- | :--------------------------------- |\n| `http://store.company.com/dir2/other.html`        | 同源 | 只有路径不同                       |\n| `http://store.company.com/dir/inner/another.html` | 同源 | 只有路径不同                       |\n| `https://store.company.com/secure.html`           | 失败 | 协议不同                           |\n| `http://store.company.com:81/dir/etc.html`        | 失败 | 端口不同 ( `http://` 默认端口是80) |\n| `http://news.company.com/dir/other.html`          | 失败 | 主机不同                           |\n\n所以说如果在当前网站上你是无法设置和获取不同原的cookie的.\n\n但是我们利用下面两个特性可以实现第三方cookie,追踪用户.\n\n- 服务端可以设置cookie\n- cookie会随着请求携带\n\n举例一个利用第三方cookie的广告\n\n假设a网站引入了一个c的广告组件,这个组件请求另一个网站c的服务端来设置cookie,这时你的浏览器上就有c的cookie了\n\n这时你再访问同样引入c的广告组件的b网站,此时你浏览器上已经有访问a时c的cookie,因此能识别出你是同一个用户,从而给你显示一样的广告.\n\n### cookie 防止XSS攻击\n\n如果我们的网站没有对用户输入进行过滤,就有可能造成xss攻击.\n\n攻击者可以通过调用document.cookie获取后把我们的cookie发送给攻击者.\n\n但是如果我们设置了HttpOnly属性后,`document.cookie`就获取不到cookie了,提高了安全性\n\n### cookie会被利用于CSRF攻击\n\n跨站请求伪造利用了cookie会被请求自动携带的特性.\n\n比如你的电脑中有银行的cookie,你在打开银行的页面的同时,打开了一个钓鱼网站,这个网站包含对银行发起请求的图片标签,直接把你的一大笔钱转走了...因为浏览器在请求银行的时候会自动把cookie带上,这样银行的服务器就会以为是已经登录的用户的请求.\n\n一般为了防止csrf,会增加其他的安全验证token.\n\n或者直接不使用cookie,而使用localStorage,loacalStorage也会被xss利用,所以要注意对用户输入进行过滤.\n\n## localStorage和sessionStorage\n\n这两个api都是随着html5加入的新api\n\n这两者的主要区别是时效性不同,大小都为5mb\n\n两者的api也是一样的\n\n主要是以key value形式的字符串存储\n\n### 缺点\n\nlocalStorage的缺点是,只能存入字符串,无法直接存储对象,所以我们每次存入和取出都要重新json处理一下...\n\n而JSON.stringify()我们知道,它对undefined funtion等一些类型无法正常处理,并且不能转换循环引用的对象,因此使用时需要注意.\n\n\n\n### 存储storage\n\n```JavaScript\n/**\n * 存储Storage\n */\nexport const setStore = (params = {}) => {\n  let {\n    name,//名称\n    content,//内容\n    type,//类型\n  } = params;\n  let obj = {\n    dataType: typeof (content),\n    content: content,\n    type: type,\n    datetime: new Date().getTime()\n  }\n  if (type) window.sessionStorage.setItem(name, JSON.stringify(obj));\n  else window.localStorage.setItem(name, JSON.stringify(obj));\n}\n```\n\n### 获取storage\n\n```javascript\n/**\n * 判断是否为空\n */\nfunction validatenull (val) {\n  if (typeof val === 'boolean') {\n    return false\n  }\n  if (typeof val === 'number') {\n    return false\n  }\n  if (val instanceof Array) {\n    if (val.length == 0) return true\n  } else if (val instanceof Object) {\n    if (JSON.stringify(val) === '{}') return true\n  } else {\n    if (val == 'null' || val == null || val == 'undefined' || val == undefined || val == '') return true\n    return false\n  }\n  return false\n}\n\n/**\n * 获取Storage\n */\nexport const getStore = (params = {}) => {\n  let {\n    name,//名称\n    debug//是否需要转换类型\n  } = params;\n  let obj = {},\n    content;\n  obj = window.sessionStorage.getItem(name);\n  if (validatenull(obj)) obj = window.localStorage.getItem(name);\n  if (validatenull(obj)) return;\n  try {\n    obj = JSON.parse(obj);\n  } catch{\n    return obj;\n  }\n  if (debug) {\n    return obj;\n  }\n  if (obj.dataType == 'string') {\n    content = obj.content;\n  } else if (obj.dataType == 'number') {\n    content = Number(obj.content);\n  } else if (obj.dataType == 'boolean') {\n    content = eval(obj.content);\n  } else if (obj.dataType == 'object') {\n    content = obj.content;\n  }\n  return content;\n}\n```\n\n### 删除storage\n\n```JavaScript\n/**\n * 删除localStorage\n */\nexport const removeStore = (params = {}) => {\n  let {\n    name,\n    type\n  } = params;\n  if (type) {\n    window.sessionStorage.removeItem(name);\n  } else {\n    window.localStorage.removeItem(name);\n  }\n}\n```\n\n### 获取storage\n\n```javascript\n/**\n * 获取全部Storage\n */\nexport const getAllStore = (params = {}) => {\n  let list = [];\n  let {\n    type\n  } = params;\n  if (type) {\n    for (let i = 0; i <= window.sessionStorage.length; i++) {\n      list.push({\n        name: window.sessionStorage.key(i),\n        content: getStore({\n          name: window.sessionStorage.key(i),\n          type: 'session'\n        })\n      })\n    }\n  } else {\n    for (let i = 0; i <= window.localStorage.length; i++) {\n      list.push({\n        name: window.localStorage.key(i),\n        content: getStore({\n          name: window.localStorage.key(i),\n        })\n      })\n\n    }\n  }\n  return list;\n}\n```\n\n### 清空全部storage\n\n```JavaScript\n/**\n * 清空全部Storage\n */\nexport const clearStore = (params = {}) => {\n  let { type } = params;\n  if (type) {\n    window.sessionStorage.clear();\n  } else {\n    window.localStorage.clear()\n  }\n}\n```\n\n\n\n### localStorage扩容\n\nLOCALFORAGE是一个兼容性强的本地存储库,它的api类似于localStorage,\n\n它对localStorage,webSQL,和indexedDB做了个平滑升级处理.\n\n默认使用的是indexed和webSQL,在你的浏览器不支持这两个的时候才会降级使用localStorage\n\nhttps://github.com/localForage/localForage\n\n## indexedDB\n\nindexedDB是一个本地关系型数据库.和webStorage同期普及到浏览器的.\n\n算是一个前端的终极本地数据存储方案\n\n对比localStorage,有以下优势\n\n- 存储量理论没有上限(实际上各个浏览器还是会进行一定的限制的)\n- 支持异步操作,性能会更高.\n- 原生支持存储js对象\n- 是个数据库,功能强大\n\nindexexDB最大的缺点是,api比较难用,功能繁琐.\n\n一般我们用LOCALFORAGE(https://github.com/localForage/localForage)就行了,一定要用indexedDB的场合也比较少,如果这样通常不如做成客户端,我用sqlite不香吗\n\n"}},"__N_SSG":true}