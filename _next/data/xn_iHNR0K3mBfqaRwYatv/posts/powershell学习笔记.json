{"pageProps":{"postData":{"id":"powershell学习笔记","title":"powershell学习笔记","lastUpdated":1584086092,"content":"\n# PowerShell学习笔记\n\n## 1.PowerShell交互式\n\n### 01.数学运算\n\n我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。\n\n```powershell\nPS C:\\pstest> 1+2+3\n6\nPS C:\\pstest> 0xABCD\n43981\nPS C:\\pstest> 3.14*10*10\n314\nPS C:\\pstest> 1+3-(2.4-5)*(7.899-4.444)\n12.983\n```\n\nPowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB\n\n```powershell\nPS C:\\pstest> 1pb/1tb\n1024\nPS C:\\pstest> 1tb/1gb\n1024\nPS C:\\pstest> 1gb/1kb\n1048576\nPS C:\\pstest> 1gb/20mb*10kb\n524288\n```\n\n假如一个网站每个页面大小为80kb，统计显示每天的PV操作为800，1个月下来占用的带宽：\n\n```powershell\nPS C:\\pstest> 80kb*800*30/1gb\n1.8310546875\n```\n\n假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数\n\n为：\n\n```powershell\nPS C:pstest> 10GB/(80KB*5)/30\n873.813333333333\n```\n\n### 02.PowerShell 执行外部命令\n\nPowershell 能够像CMD一样很好的执行外部命令。\n\n#### 通过netstat查看网络端口状态\n\n```powershell\nPS C:\\PS> netstat\n\nActive Connections\n\n  Proto  Local Address          Foreign Address        State\n  TCP    192.168.0.100:3049    192.168.0.88:7575       ESTABLISHED\n  TCP    192.168.0.100:3052    192.168.0.88:7575       ESTABLISHED\n  TCP    192.168.0.100:3061    192.168.0.88:7575       ESTABLISHED\n```\n\n#### 通过IPConfig查看自己的网络配置\n\n```powershell\nPS C:\\PS> ipconfig\n\nWindows IP Configuration\n\nEthernet adapter Local Area Connection:\n\n   Connection-specific DNS Suffix  . : www.mossfly.com\n   Link-local IPv6 Address . . . . . : fe80::b9dd:91e33:33f0:7885%10\n   IPv4 Address. . . . . . . . . . . : 192.168.140.100\n   Subnet Mask . . . . . . . . . . . : 255.255.252.0\n   Default Gateway . . . . . . . . . : 192.168.140.1\n\nTunnel adapter isatap.www.mossfly.com:\n\n   Connection-specific DNS Suffix  . : www.mossfly.com\n   Link-local IPv6 Address . . . . . : fe80::5efe:192.168.140.100%11\n   Default Gateway . . . . . . . . . :\n\nTunnel adapter Teredo Tunneling Pseudo-Interface:\n\n   Media State . . . . . . . . . . . : Media disconnected\n   Connection-specific DNS Suffix  . :\n```\n\n#### route print查看路由信息\n\n```powershell\nPS C:\\PS> route print\nIPv4 Route Table\n===========================================================================\nActive Routes:\nNetwork Destination        Netmask          Gateway       Interface  Metric\n          0.0.0.0          0.0.0.0     192.168.140.1   192.168.140.100     20\n        192.0.0.0        255.0.0.0         On-link         192.0.0.1    306\n        192.0.0.1  255.255.255.255         On-link         192.0.0.1    306\n  192.255.255.255  255.255.255.255         On-link         192.0.0.1    306\n     192.168.140.0    255.255.252.0         On-link    192.168.140.100    276\n   192.168.140.100  255.255.255.255         On-link    192.168.140.100    276\n   192.168.143.255  255.255.255.255         On-link    192.168.140.100    276\n        224.0.0.0        240.0.0.0         On-link         192.0.0.1    306\n        224.0.0.0        240.0.0.0         On-link    192.168.140.100    276\n  255.255.255.255  255.255.255.255         On-link         192.0.0.1    306\n  255.255.255.255  255.255.255.255         On-link    192.168.140.100    276\n===========================================================================\nPersistent Routes:\n  None\n\nIPv6 Route Table\n===========================================================================\nActive Routes:\n If Metric Network Destination      Gateway\n  1    306 ::1/128                  On-link\n 10    276 fe80::/64                On-link\n 11    281 fe80::5efe:192.168.140.100/128\n                                    On-link\n 10    276 fe80::b965:91f3:33a0:7285/128\n                                    On-link\n  1    306 ff00::/8                 On-link\n 10    276 ff00::/8                 On-link\n===========================================================================\nPersistent Routes:\n  None\n```\n\n#### 启动CMD控制台\n\n启动CMD控制台键入cmd或者cmd.exe,退出cmd可以通过命令exit。\n\n```powershell\nPS C:\\PS> cmd\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation.  All rights reserved.\n\nC:\\PS>exit\nPS C:\\PS>\n```\n\n#### 查找可用的Cmd控制台命令\n\nCmd.exe 通过 /c 来接收命令参数，在Cmd中help可以查看可用的命令，所以可以通过Cmd /c help 查找可用的Cmd控制台命令\n\n```powershell\nPS C:\\PS> cmd /c help\n有关某个命令的详细信息，请键入 HELP 命令名\nASSOC          显示或修改文件扩展名关联。\nATTRIB         显示或更改文件属性。\nBREAK          设置或清除扩展式 CTRL+C 检查。\nBCDEDIT        设置启动数据库中的属性以控制启动加载。\nCACLS          显示或修改文件的访问控制列表(ACL)。\nCALL           从另一个批处理程序调用这一个。\nCD             显示当前目录的名称或将其更改。\nCHCP           显示或设置活动代码页数。\nCHDIR          显示当前目录的名称或将其更改。\nCHKDSK         检查磁盘并显示状态报告。\nCHKNTFS        显示或修改启动时间磁盘检查。\nCLS            清除屏幕。\nCMD            打开另一个 Windows 命令解释程序窗口。\nCOLOR          设置默认控制台前景和背景颜色。\nCOMP           比较两个或两套文件的内容。\nCOMPACT        显示或更改 NTFS 分区上文件的压缩。\nCONVERT        将 FAT 卷转换成 NTFS。您不能转换\n               当前驱动器。\nCOPY           将至少一个文件复制到另一个位置。\nDATE           显示或设置日期。\nDEL            删除至少一个文件。\nDIR            显示一个目录中的文件和子目录。\nDISKCOMP       比较两个软盘的内容。\nDISKCOPY       将一个软盘的内容复制到另一个软盘。\nDISKPART       显示或配置磁盘分区属性。\nDOSKEY         编辑命令行、调用 Windows 命令并创建宏。\nDRIVERQUERY    显示当前设备驱动程序状态和属性。\nECHO           显示消息，或将命令回显打开或关上。\nENDLOCAL       结束批文件中环境更改的本地化。\nERASE          删除一个或多个文件。\nEXIT           退出 CMD.EXE 程序(命令解释程序)。\nFC             比较两个文件或两个文件集并显示它们之间的不同。\nFIND           在一个或多个文件中搜索一个文本字符串。\nFINDSTR        在多个文件中搜索字符串。\nFOR            为一套文件中的每个文件运行一个指定的命令。\nFORMAT         格式化磁盘，以便跟 Windows 使用。\nFSUTIL         显示或配置文件系统的属性。\nFTYPE          显示或修改用在文件扩展名关联的文件类型。\nGOTO           将 Windows 命令解释程序指向批处理程序\n               中某个带标签的行。\nGPRESULT       显示机器或用户的组策略信息。\nGRAFTABL       启用 Windows 在图形模式显示扩展字符集。\nHELP           提供 Windows 命令的帮助信息。\nICACLS         显示、修改、备份或还原文件和\n 目录的 ACL。\nIF             在批处理程序中执行有条件的处理过程。\nLABEL          创建、更改或删除磁盘的卷标。\nMD             创建一个目录。\nMKDIR          创建一个目录。\nMKLINK         创建符号链接和硬链接\nMODE           配置系统设备。\nMORE           逐屏显示输出。\nMOVE           将一个或多个文件从一个目录移动到另一个目录。\nOPENFILES      显示远程用户为了文件共享而打开的文件。\nPATH           为可执行文件显示或设置搜索路径。\nPAUSE          停止批处理文件的处理并显示信息。\nPOPD           还原由 PUSHD 保存的当前目录上一次的值。\nPRINT          打印一个文本文件。\nPROMPT         改变 Windows 命令提示。\nPUSHD          保存当前目录，然后对其进行更改。\nRD             删除目录。\nRECOVER        从损坏的磁盘中恢复可读取的信息。\nREM            记录批处理文件或 CONFIG.SYS 中的注释。\nREN            重新命名文件。\nRENAME         重新命名文件。\nREPLACE        替换文件。\nRMDIR          删除目录。\nROBOCOPY       复制文件和目录树的高级实用程序\nSET            显示、设置或删除 Windows 环境变量。\nSETLOCAL       开始用批文件改变环境的本地化。\nSC             显示或配置服务(后台处理)。\nSCHTASKS       安排命令和程序在一部计算机上按计划运行。\nSHIFT          调整批处理文件中可替换参数的位置。\nSHUTDOWN       让机器在本地或远程正确关闭。\nSORT           将输入排序。\nSTART          打开单独视窗运行指定程序或命令。\nSUBST          将驱动器号与路径关联。\nSYSTEMINFO     显示机器的具体的属性和配置。\nTASKLIST       显示包括服务的所有当前运行的任务。\nTASKKILL       终止正在运行的进程或应用程序。\nTIME           显示或设置系统时间。\nTITLE          设置 CMD.EXE 会话的窗口标题。\nTREE           以图形显示启动器或路径的目录结构。\nTYPE           显示文本文件的内容。\nVER            显示 Windows 的版本。\nVERIFY         告诉 Windows 验证文件是否正确写入磁盘。\nVOL            显示磁盘卷标和序列号。\nXCOPY          复制文件和目录树。\nWMIC           在交互命令外壳里显示 WMI 信息。\n```\n\n#### 启动外部程序\n\n为什么可以通过notpad打开记事本，不能通过wordpad打开写字板？\n因为notepad.exe位于C:Windows\\system32 这个目录，而这个目录已经默认被包含在Powershell的环境变量$env:Path中。\n\n```powershell\nC:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x\n86)\\Windows Kits\\8.1\\Windows Performance Toolkit\\;C:\\Program Files\\Microsoft SQL Server\\110\\Tools\\Binn\\;C:\\Program File\ns (x86)\\Microsoft SDKs\\TypeScript\\1.0\\;C:\\Program Files\\Microsoft\\Web Platform Installer\\\n```\n\n而wordpad.exe 所在的**“%ProgramFiles%\\Windows NT\\Accessories\\wordpad.exe**“目录却没有包含，可以先进入这个目录，再运行wordpad，或者将wordpad所在的目录加入到环境变量中，$env:Path=$env:Path+”%ProgramFiles%\\Windows NT\\Accessories”。\n\n默认键入一个字符串，powershell会将它原样输出，如果该字符串是一个命令或者启动程序，在字符串前加‘&’可以执行命令，或者启动程序。\n\n```powershell\nPS C:\\PS> \"ls\"\nls\nPS C:\\PS> &\"ls\"\n\n    Directory: C:\\PS\n\nMode                LastWriteTime     Length Name\n----                -------------     ------ ----\nd----        2011/11/23     17:25            ABC\n-a---        2011/11/23     17:36         14 a.txt\n-a---        2011/11/23     17:25          0 b.txt\n-a---        2011/11/23     17:25          0 c.txt\n-a---        2011/11/23     17:25          0 d.txt\n-a---        2011/11/23     17:37        242 test.txt\n\nPS C:\\PS> \"cmd.exe\"\ncmd.exe\nPS C:\\PS> &\"cmd.exe\"\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation.  All rights reserved.\n```\n\n\n\n\n\n\n\n### 03.PowerShell命令集\n\ncmdlets是Powershell的内部命令，cmdlet的类型名为System.Management.Automation.CmdletInfo，包含下列属性和方法：\n\n| Name                | MemberType     | Definition                                                   |\n| ------------------- | -------------- | ------------------------------------------------------------ |\n| Equals              | Method         | bool Equals(System.Object obj)                               |\n| GetHashCode         | Method         | int GetHashCode()                                            |\n| GetType             | Method         | type GetType()                                               |\n| ToString            | Method         | string ToString()                                            |\n| CommandType         | Property       | System.Management.Automation.CommandTypes CommandType {get;} |\n| DefaultParameterSet | Property       | System.String DefaultParameterSet {get;}                     |\n| Definition          | Property       | System.String Definition {get;}                              |\n| HelpFile            | Property       | System.String HelpFile {get;}                                |\n| ImplementingType    | Property       | System.Type ImplementingType {get;}                          |\n| Module              | Property       | System.Management.Automation.PSModuleInfo Module {get;}      |\n| ModuleName          | Property       | System.String ModuleName {get;}                              |\n| Name                | Property       | System.String Name {get;}                                    |\n| Noun                | Property       | System.String Noun {get;}                                    |\n| OutputType          | Property       | System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.PSTypeName, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] OutputType {get;} |\n| Parameters          | Property       | System.Collections.Generic.Dictionary`2[[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Management.Automation.ParameterMetadata, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] Parameters {get;} |\n| ParameterSets       | Property       | System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.CommandParameterSetInfo, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] ParameterSets {get;} |\n| PSSnapIn            | Property       | System.Management.Automation.PSSnapInInfo PSSnapIn {get;}    |\n| Verb                | Property       | System.String Verb {get;}                                    |\n| Visibility          | Property       | System.Management.Automation.SessionStateEntryVisibility Visibility {get;set;} |\n| DLL                 | ScriptProperty | System.Object DLL {get=$this.ImplementingType.Assembly.Location;} |\n| HelpUri             | ScriptProperty | System.Object HelpUri {get=try { # ok to cast CommandTypes enum to HelpCategory because string/indentifier for # cmdlet,function,filter,alias,externalscript is identical. # it is ok to fail for other enum values (i.e. for Application) $helpObject = get-help -Name ($this.Name) -Category ([string]($this.CommandType)) -ErrorAction SilentlyContinue# return first non-null uri (and try not to hit any strict mode things) if ($helpObject -eq $null) { return $null } if ($helpObject.psobject.properties[‘relatedLinks’] -eq $null) { return $null } if ($helpObject.relatedLinks.psobject.properties[‘navigationLink’] -eq $null) { return $null } $helpUri = [string]$( $helpObject.relatedLinks.navigationLink | %{ if ($_.psobject.properties[‘uri’] -ne $null) { $_.uri } } | ?{ $_ } \\| select -first 1 ) return $helpUri } catch {};} |\n\n**下面是全部的Cmdlets命令**\n\n每个命令有一个动词和名词组成，命令的作用一目了然。\n\n| Name                              | ModuleName                       | Help                                                  |\n| --------------------------------- | -------------------------------- | ----------------------------------------------------- |\n| Add-Computer                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135194) |\n| Add-Content                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113278) |\n| Add-History                       | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113279) |\n| Add-Member                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113280) |\n| Add-PSSnapin                      | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113281) |\n| Add-Type                          | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135195) |\n| Checkpoint-Computer               | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135197) |\n| Clear-Content                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113282) |\n| Clear-EventLog                    | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135198) |\n| Clear-History                     | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=135199) |\n| Clear-Item                        | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113283) |\n| Clear-ItemProperty                | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113284) |\n| Clear-Variable                    | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113285) |\n| Compare-Object                    | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113286) |\n| Complete-Transaction              | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135200) |\n| Connect-WSMan                     | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141437) |\n| ConvertFrom-Csv                   | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135201) |\n| ConvertFrom-SecureString          | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113287) |\n| ConvertFrom-StringData            | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113288) |\n| Convert-Path                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113289) |\n| ConvertTo-Csv                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135203) |\n| ConvertTo-Html                    | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113290) |\n| ConvertTo-SecureString            | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113291) |\n| ConvertTo-Xml                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135204) |\n| Copy-Item                         | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113292) |\n| Copy-ItemProperty                 | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113293) |\n| Debug-Process                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135206) |\n| Disable-ComputerRestore           | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135207) |\n| Disable-PSBreakpoint              | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113294) |\n| Disable-PSSessionConfiguration    | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144299) |\n| Disable-WSManCredSSP              | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141438) |\n| Disconnect-WSMan                  | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141439) |\n| Enable-ComputerRestore            | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135209) |\n| Enable-PSBreakpoint               | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113295) |\n| Enable-PSRemoting                 | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144300) |\n| Enable-PSSessionConfiguration     | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144301) |\n| Enable-WSManCredSSP               | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141442) |\n| Enter-PSSession                   | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=135210) |\n| Exit-PSSession                    | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=135212) |\n| Export-Alias                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113296) |\n| Export-Clixml                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113297) |\n| Export-Console                    | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113298) |\n| Export-Counter                    | Microsoft.PowerShell.Diagnostics | [help](http://go.microsoft.com/fwlink/?LinkID=138337) |\n| Export-Csv                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113299) |\n| Export-FormatData                 | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=144302) |\n| Export-ModuleMember               | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=141551) |\n| Export-PSSession                  | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135213) |\n| ForEach-Object                    | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113300) |\n| Format-Custom                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113301) |\n| Format-List                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113302) |\n| Format-Table                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113303) |\n| Format-Wide                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113304) |\n| Get-Acl                           | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113305) |\n| Get-Alias                         | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113306) |\n| Get-AuthenticodeSignature         | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113307) |\n| Get-ChildItem                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113308) |\n| Get-Command                       | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113309) |\n| Get-ComputerRestorePoint          | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135215) |\n| Get-Content                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113310) |\n| Get-Counter                       | Microsoft.PowerShell.Diagnostics | [help](http://go.microsoft.com/fwlink/?LinkID=138335) |\n| Get-Credential                    | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113311) |\n| Get-Culture                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113312) |\n| Get-Date                          | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113313) |\n| Get-Event                         | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113453) |\n| Get-EventLog                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113314) |\n| Get-EventSubscriber               | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135155) |\n| Get-ExecutionPolicy               | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113315) |\n| Get-FormatData                    | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=144303) |\n| Get-Help                          | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113316) |\n| Get-History                       | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113317) |\n| Get-Host                          | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113318) |\n| Get-HotFix                        | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135217) |\n| Get-Item                          | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113319) |\n| Get-ItemProperty                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113320) |\n| Get-Job                           | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113328) |\n| Get-Location                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113321) |\n| Get-Member                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113322) |\n| Get-Module                        | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=141552) |\n| Get-PfxCertificate                | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113323) |\n| Get-Process                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113324) |\n| Get-PSBreakpoint                  | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113325) |\n| Get-PSCallStack                   | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113326) |\n| Get-PSDrive                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113327) |\n| Get-PSProvider                    | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113329) |\n| Get-PSSession                     | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=135219) |\n| Get-PSSessionConfiguration        | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144304) |\n| Get-PSSnapin                      | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113330) |\n| Get-Random                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113446) |\n| Get-Service                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113332) |\n| Get-TraceSource                   | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113333) |\n| Get-Transaction                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135220) |\n| Get-UICulture                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113334) |\n| Get-Unique                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113335) |\n| Get-Variable                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113336) |\n| Get-WinEvent                      | Microsoft.PowerShell.Diagnostics | [help](http://go.microsoft.com/fwlink/?LinkID=138336) |\n| Get-WmiObject                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113337) |\n| Get-WSManCredSSP                  | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141443) |\n| Get-WSManInstance                 | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141444) |\n| Group-Object                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113338) |\n| Import-Alias                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113339) |\n| Import-Clixml                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113340) |\n| Import-Counter                    | Microsoft.PowerShell.Diagnostics | [help](http://go.microsoft.com/fwlink/?LinkID=138338) |\n| Import-Csv                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113341) |\n| Import-LocalizedData              | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113342) |\n| Import-Module                     | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=141553) |\n| Import-PSSession                  | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135221) |\n| Invoke-Command                    | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=135225) |\n| Invoke-Expression                 | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113343) |\n| Invoke-History                    | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113344) |\n| Invoke-Item                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113345) |\n| Invoke-WmiMethod                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113346) |\n| Invoke-WSManAction                | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141446) |\n| Join-Path                         | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113347) |\n| Limit-EventLog                    | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135227) |\n| Measure-Command                   | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113348) |\n| Measure-Object                    | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113349) |\n| Move-Item                         | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113350) |\n| Move-ItemProperty                 | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113351) |\n| New-Alias                         | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113352) |\n| New-Event                         | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135234) |\n| New-EventLog                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135235) |\n| New-Item                          | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113353) |\n| New-ItemProperty                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113354) |\n| New-Module                        | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=141554) |\n| New-ModuleManifest                | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=141555) |\n| New-Object                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113355) |\n| New-PSDrive                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113357) |\n| New-PSSession                     | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=135237) |\n| New-PSSessionOption               | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144305) |\n| New-Service                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113359) |\n| New-TimeSpan                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113360) |\n| New-Variable                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113361) |\n| New-WebServiceProxy               | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135238) |\n| New-WSManInstance                 | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141448) |\n| New-WSManSessionOption            | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141449) |\n| Out-Default                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113362) |\n| Out-File                          | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113363) |\n| Out-GridView                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113364) |\n| Out-Host                          | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113365) |\n| Out-Null                          | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113366) |\n| Out-Printer                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113367) |\n| Out-String                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113368) |\n| Pop-Location                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113369) |\n| Push-Location                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113370) |\n| Read-Host                         | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113371) |\n| Receive-Job                       | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113372) |\n| Register-EngineEvent              | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135243) |\n| Register-ObjectEvent              | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135244) |\n| Register-PSSessionConfiguration   | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144306) |\n| Register-WmiEvent                 | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135245) |\n| Remove-Computer                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135246) |\n| Remove-Event                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135247) |\n| Remove-EventLog                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135248) |\n| Remove-Item                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113373) |\n| Remove-ItemProperty               | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113374) |\n| Remove-Job                        | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113377) |\n| Remove-Module                     | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=141556) |\n| Remove-PSBreakpoint               | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113375) |\n| Remove-PSDrive                    | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113376) |\n| Remove-PSSession                  | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=135250) |\n| Remove-PSSnapin                   | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113378) |\n| Remove-Variable                   | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113380) |\n| Remove-WmiObject                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113381) |\n| Remove-WSManInstance              | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141453) |\n| Rename-Item                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113382) |\n| Rename-ItemProperty               | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113383) |\n| Reset-ComputerMachinePassword     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135252) |\n| Resolve-Path                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113384) |\n| Restart-Computer                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135253) |\n| Restart-Service                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113385) |\n| Restore-Computer                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135254) |\n| Resume-Service                    | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113386) |\n| Select-Object                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113387) |\n| Select-String                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113388) |\n| Select-Xml                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135255) |\n| Send-MailMessage                  | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135256) |\n| Set-Acl                           | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113389) |\n| Set-Alias                         | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113390) |\n| Set-AuthenticodeSignature         | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113391) |\n| Set-Content                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113392) |\n| Set-Date                          | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113393) |\n| Set-ExecutionPolicy               | Microsoft.PowerShell.Security    | [help](http://go.microsoft.com/fwlink/?LinkID=113394) |\n| Set-Item                          | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113395) |\n| Set-ItemProperty                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113396) |\n| Set-Location                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113397) |\n| Set-PSBreakpoint                  | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113449) |\n| Set-PSDebug                       | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113398) |\n| Set-PSSessionConfiguration        | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144307) |\n| Set-Service                       | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113399) |\n| Set-StrictMode                    | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113450) |\n| Set-TraceSource                   | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113400) |\n| Set-Variable                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113401) |\n| Set-WmiInstance                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113402) |\n| Set-WSManInstance                 | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141458) |\n| Set-WSManQuickConfig              | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkID=141463) |\n| Show-EventLog                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135257) |\n| Sort-Object                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113403) |\n| Split-Path                        | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113404) |\n| Start-Job                         | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113405) |\n| Start-Process                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135261) |\n| Start-Service                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113406) |\n| Start-Sleep                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113407) |\n| Start-Transaction                 | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135262) |\n| Start-Transcript                  | Microsoft.PowerShell.Host        | [help](http://go.microsoft.com/fwlink/?LinkID=113408) |\n| Stop-Computer                     | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135263) |\n| Stop-Job                          | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113413) |\n| Stop-Process                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113412) |\n| Stop-Service                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113414) |\n| Stop-Transcript                   | Microsoft.PowerShell.Host        | [help](http://go.microsoft.com/fwlink/?LinkID=113415) |\n| Suspend-Service                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113416) |\n| Tee-Object                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113417) |\n| Test-ComputerSecureChannel        | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=137749) |\n| Test-Connection                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135266) |\n| Test-ModuleManifest               | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=141557) |\n| Test-Path                         | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=113418) |\n| Test-WSMan                        | Microsoft.WSMan.Management       | [help](http://go.microsoft.com/fwlink/?LinkId=141464) |\n| Trace-Command                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113419) |\n| Undo-Transaction                  | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135268) |\n| Unregister-Event                  | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135269) |\n| Unregister-PSSessionConfiguration | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=144308) |\n| Update-FormatData                 | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113420) |\n| Update-List                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113447) |\n| Update-TypeData                   | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113421) |\n| Use-Transaction                   | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135271) |\n| Wait-Event                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=135276) |\n| Wait-Job                          | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113422) |\n| Wait-Process                      | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135277) |\n| Where-Object                      | Microsoft.PowerShell.Core        | [help](http://go.microsoft.com/fwlink/?LinkID=113423) |\n| Write-Debug                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113424) |\n| Write-Error                       | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113425) |\n| Write-EventLog                    | Microsoft.PowerShell.Management  | [help](http://go.microsoft.com/fwlink/?LinkID=135281) |\n| Write-Host                        | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113426) |\n| Write-Output                      | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113427) |\n| Write-Progress                    | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113428) |\n| Write-Verbose                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113429) |\n| Write-Warning                     | Microsoft.PowerShell.Utility     | [help](http://go.microsoft.com/fwlink/?LinkID=113430) |\n\n\n\n\n\n### 04.PowerShell别名\n\ncmdlet 的名称由一个动词和一个名词组成，其功能对用户来讲一目了然。但是对于一个经常使用powershell命令的人每天敲那么多命令也很麻烦啊。能不能把命令缩短一点呢？于是“别名”就应运而生了。Powershell内部也实现了很多常用命令的别名。例如Get-ChildItem，列出当前的子文件或目录。它有两个别名：ls 和 dir，这两个别名来源于unix 的shell和windows的cmd。\n因此别名有两个作用：\n\n- **继承**：继承unix-shell和windows-cmd。\n- **方便**：方便用户使用。\n\n#### 处理别名：\n\n**查询别名所指的真实cmdlet命令。**\n\n```\nPS C:\\PS> Get-Alias -name ls\n\nCommandType     Name                                                Definition\n-----------     ----                                                ----------\nAlias           ls                                                  Get-ChildItem\n\nPS C:\\PS> Get-Alias -name dir\n\nCommandType     Name                                                Definition\n-----------     ----                                                ----------\nAlias           dir                                                 Get-ChildItem\n\nPS C:\\PS> Get-Alias -name fl\n\nCommandType     Name                                                Definition\n-----------     ----                                                ----------\nAlias           fl                                                  Format-List\n\nPS C:\\PS> Get-Alias -name ft\n\nCommandType     Name                                                Definition\n-----------     ----                                                ----------\nAlias           ft                                                  Format-Table\n```\n\n#### **查看可用的别名**\n\n查看可用的别名，可以通过” ls alias:” 或者 ”Get-Alias“\n如何查看所有以Remove打头的cmdlet的命令的别名呢？\n\n```\nPS C:\\PS> dir alias: | where {$_.Definition.Startswith(\"Remove\")}\n\nCommandType     Name                                                Definition\n-----------     ----                                                ----------\nAlias           del                                                 Remove-Item\nAlias           erase                                               Remove-Item\nAlias           rbp                                                 Remove-PSBreakpoint\nAlias           rd                                                  Remove-Item\nAlias           rdr                                                 Remove-PSDrive\nAlias           ri                                                  Remove-Item\nAlias           rjb                                                 Remove-Job\nAlias           rm                                                  Remove-Item\nAlias           rmdir                                               Remove-Item\nAlias           rmo                                                 Remove-Module\nAlias           rp                                                  Remove-ItemProperty\nAlias           rsn                                                 Remove-PSSession\nAlias           rsnp                                                Remove-PSSnapin\nAlias           rv                                                  Remove-Variable\nAlias           rwmi                                                Remove-WMIObject\n```\n\n**说明**：dir alias:获取的是别名的数组，通过where对数组元素进行遍历，$_代表当前元素，alias的Definition为String类型，因为powershell支持.net，.net中的string类有一个方法Startswith。通过where过滤集合在powershell中使用非常广泛。\n\n有的cmdlet命令可能有2-3个别名，我们可以通过下面的命令查看所有别名和指向cmdlet的别名的个数。\n\n```\nPS C:\\PS> ls alias: | Group-Object definition | sort -Descending Count\n\nCount Name                      Group\n----- ----                      -----\n    6 Remove-Item               {del, erase, rd, ri...}\n    3 Set-Location              {cd, chdir, sl}\n    3 Get-History               {ghy, h, history}\n    3 Get-ChildItem             {dir, gci, ls}\n    3 Get-Content               {cat, gc, type}\n    3 Move-Item                 {mi, move, mv}\n    3 Copy-Item                 {copy, cp, cpi}\n    2 Start-Process             {saps, start}\n    2 Set-Variable              {set, sv}\n    2 Write-Output              {echo, write}\n    2 Get-Process               {gps, ps}\n    2 Invoke-History            {ihy, r}\n    2 New-PSDrive               {mount, ndr}\n    2 Stop-Process              {kill, spps}\n    2 Rename-Item               {ren, rni}\n    2 Get-Location              {gl, pwd}\n    2 Compare-Object            {compare, diff}\n    2 Where-Object              {?, where}\n    2 ForEach-Object            {%, foreach}\n    2 Clear-Host                {clear, cls}\n    1 Out-Host                  {oh}\n    1 New-PSSession             {nsn}\n    1 New-Variable              {nv}\n    1 Out-GridView              {ogv}\n    1 Pop-Location              {popd}\n    1 Tee-Object                {tee}\n    1 Remove-PSBreakpoint       {rbp}\n    1 Receive-Job               {rcjb}\n    1 Push-Location             {pushd}\n    1 mkdir                     {md}\n    1 Measure-Object            {measure}\n    1 help                      {man}\n    1 Remove-PSSnapin           {rsnp}\n    1 Out-Printer               {lp}\n    1 New-Item                  {ni}\n    1 New-Module                {nmo}\n    1 New-Alias                 {nal}\n    1 Move-ItemProperty         {mp}\n    1 Wait-Job                  {wjb}\n    1 Remove-PSDrive            {rdr}\n    1 Start-Service             {sasv}\n    1 Set-PSBreakpoint          {sbp}\n    1 Set-ItemProperty          {sp}\n    1 Start-Job                 {sajb}\n    1 Set-Alias                 {sal}\n    1 Start-Sleep               {sleep}\n    1 Set-Item                  {si}\n    1 Select-Object             {select}\n    1 Set-Content               {sc}\n    1 Sort-Object               {sort}\n    1 Remove-WMIObject          {rwmi}\n    1 Remove-Module             {rmo}\n    1 Rename-ItemProperty       {rnp}\n    1 Stop-Service              {spsv}\n    1 Set-WMIInstance           {swmi}\n    1 Remove-Job                {rjb}\n    1 Remove-Variable           {rv}\n    1 Resolve-Path              {rvpa}\n    1 Stop-Job                  {spjb}\n    1 Remove-ItemProperty       {rp}\n    1 Remove-PSSession          {rsn}\n    1 Exit-PSSession            {exsn}\n    1 Format-Custom             {fc}\n    1 Enter-PSSession           {etsn}\n    1 Export-Csv                {epcsv}\n    1 Export-PSSession          {epsn}\n    1 Format-List               {fl}\n    1 Get-PSBreakpoint          {gbp}\n    1 Get-Command               {gcm}\n    1 Get-Alias                 {gal}\n    1 Format-Table              {ft}\n    1 Format-Wide               {fw}\n    1 Export-Alias              {epal}\n    1 Clear-History             {clhy}\n    1 Clear-Item                {cli}\n    1 Clear-Content             {clc}\n    1 Add-Content               {ac}\n    1 Add-PSSnapIn              {asnp}\n    1 Clear-ItemProperty        {clp}\n    1 Disable-PSBreakpoint      {dbp}\n    1 Enable-PSBreakpoint       {ebp}\n    1 Convert-Path              {cvpa}\n    1 Clear-Variable            {clv}\n    1 Copy-ItemProperty         {cpp}\n    1 Invoke-Expression         {iex}\n    1 Invoke-Item               {ii}\n    1 Invoke-Command            {icm}\n    1 Get-Variable              {gv}\n    1 Get-WmiObject             {gwmi}\n    1 Import-Alias              {ipal}\n    1 powershell_ise.exe        {ise}\n    1 Invoke-WMIMethod          {iwmi}\n    1 Import-PSSession          {ipsn}\n    1 Import-Csv                {ipcsv}\n    1 Import-Module             {ipmo}\n    1 Get-Unique                {gu}\n    1 Get-Job                   {gjb}\n    1 Get-Member                {gm}\n    1 Get-Item                  {gi}\n    1 Get-PSCallStack           {gcs}\n    1 Get-PSDrive               {gdr}\n    1 Get-Module                {gmo}\n    1 Get-PSSnapIn              {gsnp}\n    1 Get-Service               {gsv}\n    1 Get-PSSession             {gsn}\n    1 Get-ItemProperty          {gp}\n    1 Group-Object              {group}\n```\n\n#### **创建自己的别名**\n\n给记事本创建一个别名，并查看该别名；\n\n```\nPS C:\\PS> Set-Alias -Name Edit -Value notepad\nPS C:\\PS> Edit\nPS C:\\PS> $alias:Edit\nnotepad\n```\n\n#### **删除自己的别名**\n\n别名不用删除，自定义的别名在powershell退出时会自动清除。但是请放心，powershell内置别名（诸如ls,dir,fl等）不会清除。如果你非得手工删除别名。请使用\n\n```\nPS C:\\PS> del alias:Edit\n```\n\n#### **保存自己的别名**\n\n可以使用Export-Alias将别名导出到文件，需要时再通过Import-Alias导入。但是导入时可能会有异常，提示别名已经存在无法导入：\n\n```\nPS C:\\PS> Import-Alias alias.ps1\nImport-Alias : Alias not allowed because an alias with the name 'ac' already exists.\nAt line:1 char:13\n+ Import-Alias <<<<  alias.ps1\n    + CategoryInfo          : ResourceExists: (ac:String) [Import-Alias], SessionStateException\n    + FullyQualifiedErrorId : AliasAlreadyExists,Microsoft.PowerShell.Commands.ImportAliasCommand\n```\n\n这时可以使用Force强制导入。\n\n```\nPS C:\\PS> Export-Alias alias.ps1\nPS C:\\PS> Import-Alias -Force alias.ps1\n```\n\n\n\n### 05.PowerShell通过函数扩展别名\n\n在Powershell中设置别名的确方便快捷，但是在设置别名的过程中并设置参数的相关信息。尽管别名会自动识别参数，但是如何把经常使用的参数默认设定在别名里面呢？例如Test-Connection -Count 2 -ComputerName，让-“-Count 2” 固化在别名中。\n这时简单的别名无法完成上述需求，可以通过函数来完成它，并且一旦把函数拉过来，定义别名会变得更加灵活。\n\n```\nPS C:\\PS> function test-conn { Test-Connection  -Count 2 -ComputerName $args}\nPS C:\\PS> Set-Alias tc test-conn\nPS C:\\PS> tc localhost\n\nSource        Destination     IPV4Address      IPV6Address                              Bytes    Time(ms)\n------        -----------     -----------      -----------                              -----    --------\ntest-me-01   localhost       127.0.0.1        ::1                                      32       0\ntest-me-01   localhost       127.0.0.1        ::1                                      32       0\n```\n\n有了函数牵线，别名可以完成更高级更强大的功能，其中$args为参数的占位符。\n\n\n\n\n\n\n\n### 06.PowerShell执行文件和脚本\n\n象运行可执行文件一样，Powershell运行文件和脚本，也必须使用绝对路径或者相对路径，或者要运行的文件必须定义在可受信任的环境变量中。\n\n#### 关于脚本\n\n脚本和批处理都属于伪可执行文件，它们只是包含了若干命令行解释器能够解释和执行的命令行代码。\n\n#### 执行批处理文件\n\n批处理是扩展名为”.bat”的文本文件，它可以包含任何cmd控制台能够处理的命令。当批处理文件被打开，Cmd控制台会逐行执行每条命令。那Powershell能够直接执行批处理吗？\n将下列命令保存为ping.bat\n\n```\n@echo off\necho batch File Test\npause\nDir %windir%/system\n```\n\n然后执行ping\n屏幕会打印ping命令帮助，说明调用的ping cmd 而不是ping.bat。\n改为：\n\n```\nPS C:\\PS> ./ping\nbatch File Test\nPress any key to continue . . .\n Volume in drive C has no label.\n Volume Serial Number is 4E9B-D846\n\n Directory of C:Windowssystem\n\n2009/06/11  05:21            69,584 avicap.dll\n2009/06/11  05:21           109,456 avifile.dll\n2009/07/14  05:41            32,816 COMMDLG.DLL\n2009/07/14  05:41             2,000 keyboard.drv\n2009/06/11  05:42             9,936 lzexpand.dll\n2009/06/11  05:21            73,376 mciavi.drv\n2009/06/11  05:21            25,264 mciseq.drv\n2009/06/11  05:21            28,160 mciwave.drv\n2009/07/14  05:41            68,992 MMSYSTEM.DLL\n2009/07/14  05:41             1,152 mmtask.tsk\n2009/07/14  05:41             2,032 mouse.drv\n2009/06/11  05:21           126,912 msvideo.dll\n2009/06/11  05:42            82,944 olecli.dll\n2009/07/14  05:41            24,064 OLESVR.DLL\n2009/07/14  05:41             5,120 SHELL.DLL\n2009/07/14  05:41             1,744 sound.drv\n2009/06/11  05:25             5,532 stdole.tlb\n2009/07/14  05:41             3,360 system.drv\n2009/07/14  05:41             4,048 TIMER.DRV\n2009/06/11  05:42             9,008 ver.dll\n2009/07/14  05:41             2,176 vga.drv\n2009/07/14  05:41            12,704 WFWNET.DRV\n              22 File(s)        700,380 bytes\n               2 Dir(s)  75,927,420,928 bytes free\n```\n\n这时运行的是批处理。\n\n通过cmd进入cmd控制台输入ping发现执行的不是ping命令，而是直接运行ping.bat ，也就是说可以通过.bat 覆盖cmd命令。这种机制很危险，如果有人侵入电脑，并将系统内部命令篡改成自己批处理，那就太悲剧了。 这种命令与脚本的混淆不会发生在powershell中，因为powershell有更安全的机制。\n\n#### **执行VB脚本文件**\n\n将下列命令保存为test.vbs\n\n```\nSet wmi = GetObject(\"winmgmts:\")\nSet collection = wmi.ExecQuery(\"select * from Win32_Process\")\nFor Each process in collection\nWScript.Echo process.getObjectText_\nNext\n```\n\n执行 .\\test.vbs 会遍历当前Win32进程，并把每个进程的详细信息通过窗口显示出来。\n怎样让VB脚本的通过控制台输出呢？\n**Wscript //H:CScript**\n怎样还原VB脚本通过窗口输出呢？\n**WScript //H:WScript**\n在powershell中执行VB脚本\n\n```\nPS C:\\PS> cscript.exe .test.vbs\nMicrosoft (R) Windows Script Host Version 5.8\nCopyright (C) Microsoft Corporation. All rights reserved.\n\ninstance of Win32_Process\n{\n        Caption = \"System Idle Process\";\n        CreationClassName = \"Win32_Process\";\n        CSCreationClassName = \"Win32_ComputerSystem\";\n        CSName = \"test-me-01\";\n        Description = \"System Idle Process\";\n        Handle = \"0\";\n        HandleCount = 0;\n        KernelModeTime = \"484113379271\";\n        Name = \"System Idle Process\";\n        OSCreationClassName = \"Win32_OperatingSystem\";\n        OSName = \"Microsoft Windows 7 Enterprise |C:Windows|DeviceHarddisk0Partition2\";\n        OtherOperationCount = \"0\";\n        OtherTransferCount = \"0\";\n        PageFaults = 0;\n        PageFileUsage = 0;\n        ParentProcessId = 0;\n        PeakPageFileUsage = 0;\n        PeakVirtualSize = \"0\";\n        PeakWorkingSetSize = 0;\n        Priority = 0;\n        PrivatePageCount = \"0\";\n        ProcessId = 0;\n        QuotaNonPagedPoolUsage = 0;\n        QuotaPagedPoolUsage = 0;\n        QuotaPeakNonPagedPoolUsage = 0;\n        QuotaPeakPagedPoolUsage = 0;\n        ReadOperationCount = \"0\";\n        ReadTransferCount = \"0\";\n        SessionId = 0;\n        ThreadCount = 2;\n        UserModeTime = \"0\";\n        VirtualSize = \"0\";\n        WindowsVersion = \"6.1.7601\";\n        WorkingSetSize = \"24576\";\n        WriteOperationCount = \"0\";\n        WriteTransferCount = \"0\";\n};\n```\n\n#### **执行powershell脚本**\n\nPowershell拥有自己的脚本，扩展名为“.ps1”\n\n```\nPS C:\\PS> echo \"dir;Get-PSProvider;help dir\" >test.ps1\nPS C:\\PS> Get-Content ./test.ps1\ndir;Get-PSProvider;help dir\nPS C:\\PS> ./test.ps1\n```\n\n初次执行脚本时，可能会碰到一个异常：\n\n```powershell\nFile ” C:\\PS\\test.ps1″ cannot be loaded because the\nexecution of scripts is disabled on this system. Please see\n“get-help about_signing” for more details.\nAt line:1 char:10\n+ .test.ps1 <<<<\n```\n\n\n\n这是powershell的默认安全设置禁用了执行脚本，要启用这个功能需要拥有管理员的权限。\n\n#### **Powershell调用入口的优先级**\n\n**别名**：控制台首先会寻找输入是否为一个别名，如果是，执行别名所指的命令。因此我们可以通过别名覆盖任意powershell命令，因为别名的优先级最高。\n\n**函数**：如果没有找到别名，会继续寻找函数，函数类似别名，只不过它包含了更多的powershell命令。因此可以自定义函数扩充cmdlet 把常用的参数给固化进去。\n\n**命令**：如果没有找到函数，控制台会继续寻找命令，即cmdlet，powershell的内部命令。\n\n**脚本**：没有找到命令，继续寻找扩展名为“.ps1”的Powershell脚本。\n\n**文件**：没有找到脚本，会继续寻找文件，如果没有可用的文件，控制台会抛出异常。\n\n```powershell\n\n\nThe term ‘now’ is not recognized as the name of a cmdlet, function, script file, or operable program. Chec\ng of the name, or if a path was included, verify that the path is correct and try again.\nAt line:1 char:4\n+ now <<<<\n+ CategoryInfo : ObjectNotFound: (now:String) [], CommandNotFoundException\n+ FullyQualifiedErrorId : CommandNotFoundException\n\n```\n\n\n\n\n\n## 2.PowerShell变量\n\n### 01.定义变量\n\n变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作。\n\n```powershell\n#定义变量\n$a=10\n$b=4\n#计算变量\n$result=$a*$b\n$msg=\"保存文本\"\n\n#输出变量\n$result\n$msg\n\n40\n保存文本\n```\n\npowershell 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$.\n创建好了变量后，可以通过变量名输出变量，也可以把变量名存在字符串中。但是有个例外单引号中的字符串不会识别和处理变量名。\n\n#### 选择变量名\n\n在powershell中变量名均是以美元符”`$`”开始，剩余字符可以是数字、字母、下划线的任意字符，并且powershell变量名**大小写不敏感**（$a和$A 是同一个变量)。\n某些特殊的字符在powershell中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。\n\n```\nPS C:\\test> ${\"I\"like $}=\"mossfly\"\nPS C:\\test> ${\"I\"like $}\nmossfly\n```\n\n#### 赋值和返回值\n\n赋值操作符为“=”，几乎可以把任何数据赋值给一个变量，甚至一条cmdlet命令\n，为什么，因为Powershell支持对象，对象可以包罗万象。\n\n```powershell\nPS C:\\test> $item=Get-ChildItem .\nPS C:\\test> $item\n\n    Directory: C:\\test\n\nMode                LastWriteTime     Length Name\n----                -------------     ------ ----\nd----        2011/11/23     17:25            ABC\n-a---        2011/11/24     18:30      67580 a.html\n-a---        2011/11/24     20:04      26384 a.txt\n-a---        2011/11/24     20:26      12060 alias\n-a---        2011/11/24     20:27      12060 alias.ps1\n-a---        2011/11/23     17:25          0 b.txt\n-a---        2011/11/23     17:25          0 c.txt\n-a---        2011/11/23     17:25          0 d.txt\n-a---        2011/11/25     11:20        556 employee.xml\n-a---        2011/11/24     17:37       7420 name.html\n-a---        2011/11/28     15:30         63 ping.bat\n-a---        2011/11/24     17:44     735892 Powershell_Cmdlets.html\n-a---        2011/11/28     17:03         60 test.ps1\n-a---        2011/11/23     17:37        242 test.txt\n-a---        2011/11/28     16:42        170 test.vbs\n\nPS C:\\test> $result=3000*(1/12+0.0075)\nPS C:\\test> $result\n272.5\n```\n\n#### 给多个变量同时赋值\n\n赋值操作符不仅能给一个变量赋值，还可以同时给多个变量赋相同的值。\n\n```powershell\nPS C:\\test> $a=$b=$c=123\nPS C:\\test> $a\n123\nPS C:\\test> $b\n123\nPS C:\\test> $c\n123\n```\n\n#### 交换变量的值\n\n要交换两个变量的值，传统的程序语言至少需要三步，并且还需定义一个中间临时变量。\n\n```powershell\n$Value1 = 10\n$Value2 = 20\n$Temp = $Value1\n$Value1 = $Value2\n$Value2 = $Temp\n```\n\n在powershell中，交换两个变量的值，这个功能变得非常简单。\n\n```powershell\nPS C:\\test> $value1=10\nPS C:\\test> $value2=20\nPS C:\\test> $value1,$value2=$value2,$value1\nPS C:\\test> $value1\n20\nPS C:\\test> $value2\n10\n```\n\n#### 查看正在使用的变量\n\nPowershell将变量的相关信息的记录存放在名为variable:的驱动中。如果要查看所有定义的变量，可以直接遍历variable:\n\n```powershell\nPS C:\\test> ls variable:\n\nName                           Value\n----                           -----\n\"I\"like $                      mossfly\n$                              cls\n?                              True\n^                              cls\n_\n1                              1\na                              123\nargs                           {}\nb                              123\nc                              123\nConfirmPreference              High\nConsoleFileName\nDebugPreference                SilentlyContinue\n。。。\n```\n\n#### 查找变量\n\n因为有虚拟驱动variable:的存在，可以象查找文件那样使用通配符查找变量。例如要查询以value打头的变量名。\n\n```powershell\nPS C:\\test> ls variable:value*\n\nName                           Value\n----                           -----\nvalue1                         20\nvalue2                         10\n```\n\n#### 验证变量是否存在\n\n验证一个变量是否存在，仍然可以象验证文件系统那样，使用cmdlet Test-Path。为什么？因为变量存在变量驱动器中。\n\n```powershell\nPS C:\\test> Test-Path variable:value1\nTrue\nPS C:\\test> Test-Path variable:value2\nTrue\nPS C:\\test> Test-Path variable:valueUnkonw\nFalse\n```\n\n#### 删除变量\n\n因为变量会在powershell退出或关闭时，自动清除。一般没必要删除，但是你非得删除，也可以象删除文件那样删除它。\n\n```powershell\nPS C:\\test> Test-Path variable:value1\nTrue\nPS C:\\test> del variable:value1\nPS C:\\test> Test-Path variable:value1\nFalse\n```\n\n#### 使用专用的变量命令\n\n为了管理变量，powershell提供了五个专门管理变量的命令Clear-Variable，Get-Variable，New-Variable，Remove-Variable，Set-Variable。因为虚拟驱动器variable:的存在，clear，remove，set打头的命令可以被代替。但是Get-Variable，New-Variable。却非常有用new-variable可以在定义变量时，指定变量的一些其它属性，比如访问权限。同样Get-Variable也可以获取这些附加信息。\n\n#### 变量写保护\n\n可以使用New-Variable 的option选项 在创建变量时，给变量加上只读属性，这样就不能给变量重新赋值了。\n\n```powershell\nPS C:\\test> New-Variable num -Value 100 -Force -Option readonly\nPS C:\\test> $num=101\nCannot overwrite variable num because it is read-only or constant.\nAt line:1 char:5\n+ $num <<<< =101     + CategoryInfo          : WriteError: (num:String) [], SessionStateUnauthorizedAccessException     + FullyQualifiedErrorId : VariableNotWritable PS C:\\test> del Variable:num\nRemove-Item : Cannot remove variable num because it is constant or read-only. If the variable is read-only,\nration again specifying the Force option.\nAt line:1 char:4\n+ del <<<<  Variable:num\n    + CategoryInfo          : WriteError: (num:String) [Remove-Item], SessionStateUnauthorizedAccessExcepti\n    + FullyQualifiedErrorId : VariableNotRemovable,Microsoft.PowerShell.Commands.RemoveItemCommand\n```\n\n但是可以通过删除变量，再重新创建变量更新变量内容。\n\n```powershell\nPS C:\\test> del Variable:num -Force\nPS C:\\test> $num=101\nPS C:\\test> $num\n101\n```\n\n有没有权限更高的变量，有，那就是：选项Constant，常量一旦声明，不可修改\n\n```powershell\nPS C:\\test> new-variable num -Value \"strong\" -Option constant\n\nPS C:\\test> $num=\"why? can not delete it.\"\nCannot overwrite variable num because it is read-only or constant.\nAt line:1 char:5\n+ $num <<<< =\"why? can not delete it.\"     + CategoryInfo          : WriteError: (num:String) [], SessionStateUnauthorizedAccessException     + FullyQualifiedErrorId : VariableNotWritable PS C:\\test> del Variable:num -Force\nRemove-Item : Cannot remove variable num because it is constant or read-only. If the variable is read-only,\nration again specifying the Force option.\nAt line:1 char:4\n+ del <<<<  Variable:num -Force\n    + CategoryInfo          : WriteError: (num:String) [Remove-Item], SessionStateUnauthorizedAccessExcepti\n    + FullyQualifiedErrorId : VariableNotRemovable,Microsoft.PowerShell.Commands.RemoveItemCommand\n```\n\n#### 变量描述\n\n在New-Variable 可以通过-description 添加变量描述，但是变量描述默认不会显示，可以通过Format-List 查看。\n\n```powershell\nPS C:\\test> new-variable name -Value \"me\" -Description \"This is my name\"\nPS C:\\test> ls Variable:name | fl *\n\nPSPath        : Microsoft.PowerShell.CoreVariable::name\nPSDrive       : Variable\nPSProvider    : Microsoft.PowerShell.CoreVariable\nPSIsContainer : False\nName          : name\nDescription   : This is my name\nValue         : me\nVisibility    : Public\nModule        :\nModuleName    :\nOptions       : None\nAttributes    : {}\n```\n\n\n\n\n\n### 02.PowerShell 自动化变量\n\n\n\nPowershell 自动化变量 是那些一旦打开Powershell就会自动加载的变量。\n这些变量一般存放的内容包括\n\n1. **用户信息**：例如用户的根目录$home\n2. **配置信息**:例如powershell控制台的大小，颜色，背景等。\n3. **运行时信息**：例如一个函数由谁调用，一个脚本运行的目录等。\n\n```powershell\nPS> $HOME\nC:\\Users\\test\nPS> $currentProcessID=$pid\nPS> $currentProcessID\n5356\nPS> Get-Process -Id $pid\n\nHandles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName\n-------  ------    -----      ----- -----   ------     -- -----------\n    390      10    30604      33100   172     1.11   5356 powershell\n\nPS> $PROFILE\nC:\\Users\\test\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1\n```\n\npowershell中的某些自动化变量只能读，不能写。例如:$Pid。\n可以通过Get-Help about_Automatic_variables查看Automatic_variables的帮助。\nTOPIC\nabout_Automatic_Variables\n\n**主题**\nabout_Automatic_Variables\n\n**简短说明**\n说明存储 Windows PowerShell 状态信息的变量。\n这些变量由 Windows PowerShell 创建并维护。\n\n**详细说明**\n下面是 Windows PowerShell 中的自动变量的列表：\n\n**$$**\n包含会话所收到的最后一行中的最后一个令牌。\n\n**$?**\n包含最后一个操作的执行状态。如果最后一个操作成功，则包含 TRUE，失败则包含 FALSE。\n\n**$^**\n包含会话所收到的最后一行中的第一个令牌。\n\n**$_**\n包含管道对象中的当前对象。在对管道中的每个对象或所选对象执行操作的命令中，可以使用此变量。\n\n**$Args**\n包含由未声明参数和/或传递给函数、脚本或脚本块的参数值组成的数组。\n在创建函数时可以声明参数，方法是使用 param 关键字或在函数名称后添加以圆括号括起、逗号\n分隔的参数列表。\n\n**$ConsoleFileName**\n包含在会话中最近使用的控制台文件 (.psc1) 的路径。在通过 PSConsoleFile 参数启动\nWindows PowerShell 或使用 Export-Console cmdlet 将管理单元名称导出到控制台文件\n时，将填充此变量。\n\n在使用不带参数的 Export-Console cmdlet 时，它自动更新在会话中最近使用的控制台文件。\n可以使用此自动变量确定要更新的文件。\n\n**$Error**\n包含错误对象的数组，这些对象表示最近的一些错误。最近的错误是该数组中的第一个错误对象\n($Error[0])。\n\n**$Event**\n包含一个 PSEventArgs 对象，该对象表示一个正在被处理的事件。\n此变量只在事件注册命令（例如 Register-ObjectEvent）的 Action 块内填充。\n此变量的值是 Get-Event cmdlet 返回的同一个对象。\n因此，可以在 Action 脚本块中使用 $Event 变量的属性（例如\n$Event.TimeGenerated）。\n\n**$EventSubscriber**\n包含一个 PSEventSubscriber 对象，该对象表示正在被处理的事件的事件订阅者。\n此变量只在事件注册命令的 Action 块内填充。此变量的值\n是 Get-EventSubscriber cmdlet 返回的同一个对象。\n\n**$ExecutionContext**\n包含一个 EngineIntrinsics 对象，该对象表示 Windows PowerShell 主机的执行上下文。\n可以使用此变量来查找可用于 cmdlet 的执行对象。\n\n**$False**\n包含 FALSE。可以使用此变量在命令和脚本中表示 FALSE，而不是使用字符串”false”。如果\n该字符串转换为非空字符串或非零整数，则可将该字符串解释为 TRUE。\n\n**$ForEach**\n包含 ForEach-Object 循环的枚举数。可以对 $ForEach 变量的值使用枚举数的属性和方法。\n此变量仅在运行 For 循环时存在，循环完成即会删除。\n\n**$Home**\n包含用户的主目录的完整路径。此变量等效于 %homedrive%%homepath% 环境变量。\n\n**$Host**\n包含一个对象，该对象表示 Windows PowerShell 的当前主机应用程序。可以使用此变量在命\n令中表示当前主机，或者显示或更改主机的属性，如 $Host.version、$Host.CurrentCulture\n或 $host.ui.rawui.setbackgroundcolor(“Red”)。\n\n**$Input**\n一个枚举数，它包含传递给函数的输入。$Input 变量区分大小写，只能用于函数和脚本块。（脚\n本块本质上是未命名的函数。）在函数的 Process 块中，$Input 变量包含当前位于管道中的对\n象。在 Process 块完成后，$Input 的值为 NULL。如果函数没有 Process 块，则 $Input\n的值可用于 End 块，它包含函数的所有输入。\n\n**$LastExitCode**\n包含运行的最后一个基于 Windows 的程序的退出代码。\n\n**$Matches**\n$Matches 变量与 -match 和 -not match 运算符一起使用。\n将标量输入提交给 -match 或 -notmatch 运算符时，如果检测到匹配，则会返回一个布尔值，\n并使用由所有匹配字符串值组成的哈希表填充 $Matches 自动变量。有关 -match 运算符的详细\n信息，请参阅 about_comparison_operators。\n\n**$MyInvocation**\n包含一个对象，该对象具有有关当前命令（如脚本、函数或脚本块）的信息。可以使用该对象中的\n信息（如脚本的路径和文件名 ($myinvocation.mycommand.path) 或函数的名称\n($myinvocation.mycommand.name)）来标识当前命令。对于查找正在运行的脚本的名称，这非常有用。\n\n**$NestedPromptLevel**\n包含当前提示级别。值 0 指示原始提示级别。该值在进入嵌套级别时递增，在退出嵌套级别时递减。\n\n例如，在使用 $Host.EnterNestedPrompt 方法时，Windows PowerShell 会出现嵌套命令\n提示符。在 Windows PowerShell 调试程序中到达断点时，Windows PowerShell 也会出现嵌\n套命令提示符。\n\n在进入嵌套提示时，Windows PowerShell 暂停当前命令，保存执行上下文，并递增\n$NestedPromptLevel 变量的值。要创建更多嵌套命令提示符（最多 128 级）或返回到原始命\n令提示符，请完成命令，或键入”exit”。\n\n$NestedPromptLevel 变量有助于跟踪提示级别。可以创建包含此值的备用 Windows\nPowerShell 命令提示符，以使此值始终可见。\n\n**$NULL**\n包含 NULL 或空值。可以在命令和脚本中使用此变量表示 NULL，而不是使用字符串”NULL”。\n如果该字符串转换为非空字符串或非零整数，则可将该字符串解释为 TRUE。\n\n**$PID**\n包含承载当前 Windows PowerShell 会话的进程的进程标识符 (PID)。\n\n**$Profile**\n包含当前用户和当前主机应用程序的 Windows PowerShell 配置文件的完整路径。可以在命令\n中使用此变量表示配置文件。例如，可以在命令中使用此变量确定是否已创建某个配置文件：\n\ntest-path $profile\n\n也可以在命令中使用此变量创建配置文件：\n\nnew-item -type file -path $pshome -force\n\n此外，还可以在命令中使用此变量在记事本中打开配置文件：\n\nnotepad $profile\n\n**$PSBoundParameters**\n包含活动参数及其当前值的字典。只有在声明参数的作用域（如脚本或函数）中，\n此变量才有值。可以使用此变量显示或更改参数的当前值，也可以将参数值传递给\n其他脚本或函数。\n\n例如：\n\nfunction test {\nparam($a, $b)\n\n\\# Display the parameters in dictionary format.\n$psboundparameters\n\n\\# Call the Test1 function with $a and $b.\ntest1 @psboundparameters\n**}**\n\n**$PsCmdlet**\n包含一个对象，该对象表示正在运行的 cmdlet 或高级函数。\n\n可以在 cmdlet 或函数代码中使用该对象的属性和方法来响应使用的条件。例如，\nParameterSetName 属性包含正在使用的参数集的名称，而 ShouldProcess 方法将 WhatIf\n和 Confirm 参数动态添加到 cmdlet。\n\n有关 $PSCmdlet 自动变量的详细信息，请参阅 about_Functions_Advanced。\n\n**$PsCulture**\n包含操作系统中当前所用的区域性的名称。区域性确定数字、货币和日期等项的显示格式。这是系\n统的 System.Globalization.CultureInfo.CurrentCulture.Name 属性的值。要获取系统\n的 System.Globalization.CultureInfo 对象，请使用 Get-Culture cmdlet。\n\n**$PSDebugContext**\n在调试期间，此变量包含有关调试环境的信息。在其他时间，此变量包含 NULL 值。因此，可以使\n用此变量指示调试程序是否拥有控制权。填充之后，此变量包含一个具有 Breakpoints 和\nInvocationInfo 属性的 PsDebugContext 对象。InvocationInfo 属性有多个十分有用的\n属性，包括 Location 属性。Location 属性指示正在调试的脚本的路径。\n\n**$PsHome**\n包含 Windows PowerShell 的安装目录的完整路径（通常为\n%windir%System32WindowsPowerShellv1.0）。可以在 Windows PowerShell 文件\n的路径中使用此变量。例如，下面的命令在概念性帮助主题中搜索”variable”一词：\n\nselect-string -pattern variable -path $pshome*.txt\n\n**$PSScriptRoot**\n包含要从中执行脚本模块的目录。\n通过此变量，脚本可以使用模块路径来访问其他资源。\n\n**$PsUICulture**\n包含操作系统中当前所用的用户界面 (UI) 区域性的名称。UI 区域性确定哪些文本字符串用于用户\n界面元素（如菜单和消息）。这是系统的\nSystem.Globalization.CultureInfo.CurrentUICulture.Name 属性的值。要获取系统\n的 System.Globalization.CultureInfo 对象，请使用 Get-UICulture cmdlet。\n\n**$PsVersionTable**\n包含一个只读哈希表，该哈希表显示有关在当前会话中运行的 Windows PowerShell 版本的详\n细信息。\n该表包括下列项：\n\n- CLRVersion： 公共语言运行时 (CLR) 的版本\n- BuildVersion： 当前版本的内部版本号\n- PSVersion： Windows PowerShell 版本号\n- WSManStackVersion： WS-Management 堆栈的版本号\n- PSCompatibleVersions： 与当前版本兼容的 Windows PowerShell 版本\n- SerializationVersion ：序列化方法的版本\n- PSRemotingProtocolVersion：Windows PowerShell 远程管理协议的版本\n\n**$Pwd**\n包含一个路径对象，该对象表示当前目录的完整路径。\n\n**$Sender**\n包含生成此事件的对象。此变量只在事件注册命令的 Action 块内填充。\n此变量的值也可在 Get-Event 返回的 PSEventArgs\n(System.Management.Automation.PSEventArgs) 对象的 Sender 属性中找到。\n\n**$ShellID**\n包含当前 shell 的标识符。\n\n**$SourceArgs**\n包含表示正在被处理的事件的事件参数的对象。此变量只在事件注册命令的 Action\n块内填充。此变量的值也可在 Get-Event 返回的 PSEventArgs\n(System.Management.Automation.PSEventArgs) 对象的 SourceArgs 属性中找到。\n\n**$SourceEventArgs**\n包含一个对象，该对象表示从正在被处理的事件的 EventArgs 中派生出的\n第一个事件参数。此变量只在事件注册命令的 Action 块内填充。\n此变量的值也可在 Get-Event 返回的 PSEventArgs\n(System.Management.Automation.PSEventArgs) 对象的 SourceArgs 属性中找到。\n\n**$This**\n在定义脚本属性或脚本方法的脚本块中，$This 变量引用要扩展的对象。\n\n**$True**\n包含 TRUE。可以在命令和脚本中使用此变量表示 TRUE。\n\n**另请参阅**\nabout_Hash_Tables\nabout_Preference_Va\n\nriables\nabout_Variables\n\n\n\n\n\n\n\n### 03.环境变量\n\n传统的控制台一般没有象Powershell这么高级的变量系统。它们都是依赖于机器本身的环境变量，进行操作 。环境变量对于powershell显得很重要，因为它涵盖了许多操作系统的细节信息。此外，powershell中的变量只存在于powershell内部的会话中，一旦powershell关闭，这些变量就会自生自灭。但是如果环境变量被更新了，它会继续保存在操作系统中，即使其它程序也可以调用它。\n\n#### 读取特殊的环境变量\n\n通过环境变量读取Windows操作系统的安装路径，和默认应用程序的安装路径。\n\n```powershell\nPS> $env:windir\nC:\\Windows\nPS> $env:ProgramFiles\nC:\\Program Files\n```\n\n通过$env:，这就提示powershell忽略基本的variable:驱动器，而是去环境变量env:驱动器中寻找变量。为了和其它变量保持一致，powershell环境变量也可以象其它变量那样使用。比如你可以把它插入到文本中。\n\n```powershell\nPS> \"My computer name $env:COMPUTERNAME\"\nMy computer name MYHome-test-01\n```\n\n#### 查找环境变量\n\nPowershell把所有环境变量的记录保存在env: 虚拟驱动中，因此可以列出所有环境变量 。一旦查出环境变量的名字就可以使用$env:name 访问了。\n\n```powershell\nPS> ls env:\nName                           Value\n----                           -----\nALLUSERSPROFILE                C:\\ProgramData\nAPPDATA                        C:\\User\\sv-test\\Home\\AppData\\Roaming\nCommonProgramFiles             C:\\Program Files\\Common Files\nCOMPUTERNAME                   MYHome-test-01\nComSpec                        C:\\Windows\\system32\\cmd.exe\nFP_NO_HOST_CHECK               NO\nHOMEDRIVE                      C:\nHOMEPATH                       Users\\v-test\\Home\n```\n\n#### 创建新的环境变量\n\n创建新环境变量的方法和创建其它变量一样，只需要指定env:虚拟驱动器即可\n\n```powershell\nPS> $env:TestVar1=\"This is my environment variable\"\nPS> $env:TestVar2=\"Hollow, environment variable\"\nPS> ls env:Test*\n\nName                           Value\n----                           -----\nTestVar1                       This is my environment variable\nTestVar2                       Hollow, environment variable\n```\n\n#### 删除和更新环境变量\n\n在powershell删除和更新环境变量和常规变量一样。例如要删除环境变量中的 windir，\n\n```powershell\nPS> del env:windir\nPS> $env:windir\nPS>\n```\n\n可以更新环境变量$env:OS 为linux redhat。\n\n```powershell\nPS> $env:OS\nWindows_NT\nPS>  $env:OS=\"Redhat Linux\"\nPS> $env:OS\nRedhat Linux\n```\n\n这样直接操作环境变量，会不会不安全？事实上很安全，因为$env：中的环境变量只是机器环境变量的一个副本，即使你更改了它，下一次重新打开时，又会恢复如初。（.NET方法更新环境变量除外）\n\n我们可以将受信任的文件夹列表追加到环境变量的末尾，这样就可以直接通过相对路径执行这些文件下的文件或者脚本，甚至省略扩展名都可以。\n\n```powershell\nPS> md .myscript\n\n    Directory:\n\nMode                LastWriteTime     Length Name\n----                -------------     ------ ----\nd----        2011/11/29     18:20            myscript\n\nPS> cd .myscript\nPSmyscript> \"write-host 'Hollow , Powershell'\" > hollow.ps1\nPSmyscript> .hollow.ps1\nHollow , Powershell\nPSmyscript> cd ..\nPS> $env:Path+=\";C:PowerShellmyscript\"\nPS> hollow.ps1\nHollow , Powershell\nPS> hollow\nHollow , Powershell\n```\n\n#### 环境变量更新生效\n\n上述对于环境变量的操作只会影响当前powershell会话，并没有更新在机器上。\n.NET方法[environment]::SetEnvironmentvariable操作可以立刻生效。\n下面的例子对当前用户设置环境变量，经测试，重新打开powershell仍然存在\n\n```powershell\nPS> [environment]::SetEnvironmentvariable(\"Path\", \";c:\\powershellscript\", \"User\")\nPS> [environment]::GetEnvironmentvariable(\"Path\", \"User\")\n;c:\\powershellscript\n```\n\n\n\n\n\n\n\n### 04.PowerShell驱动器变量\n\nPowershell中所有不是我们自己的定义的变量都属于驱动器变量（比如环境变量），它的前缀只是提供给我们一个可以访问信息的虚拟驱动器.。例如env:windir，象env：驱动器上的一个”文件”，我们通过$访问它，就会返回”文件”的内容。\n\n#### 直接访问文件路径\n\n通过驱动器直接访问文件路径，也支持物理驱动器，必须把文件路径放在封闭的大括号中，因为正常的文件路径包含两个特殊字符“:”和“”，有可能会被powershell解释器误解。\n\n```powershell\nPS> ${c:/powershell/ping.bat}\n@echo off\necho batch File Test\npause\nDir %windir%/system\n\nPS> ${c:autoexec.bat}\nREM Dummy file for NTVDM\n```\n\n上述的例子有一个限制，就是${$env:HOMEDRIVE/Powershellping.bat}不能识别，原因是$后花括号中的路径必须是具体的路径，而不能带返回值。\n解决方法：\n\n```powershell\nPS> Invoke-Expression \"`${$env:HOMEDRIVE/Powershell/ping.bat}\"\n@echo off\necho batch File Test\npause\nDir %windir%/system\n```\n\n因为反引号”`”放在$前，会把$解析成普通字符，解释器会继续去解析第二个$，发现env:HOMEDRIVE，将其替换成c，到此 Invoke-Expression的参数就变成了${C:/Powershell/ping.bat},继续执行这个表达式就可以了。\n查看Powershell支持的驱动器，可以使用Get-PSDrive查看。\n\n| Name     | Root               | Description                                                  |\n| -------- | ------------------ | ------------------------------------------------------------ |\n| A        | A:                 |                                                              |\n| Alias    |                    | Drive containing a view of the aliases stored in session state. |\n| C        | C:                 |                                                              |\n| cert     |                    | X509 Certificate Provider                                    |\n| E        | E:                 |                                                              |\n| Env      |                    | The drive containing a view of the environment variables for the process. |\n| Function |                    | The drive containing a view of the functions stored in session state. |\n| HKCU     | HKEY_CURRENT_USER  | The software settings for the current user.                  |\n| HKLM     | HKEY_LOCAL_MACHINE | The configuration settings for the local machine.            |\n| Variable |                    | The drive containing a view of those variables stored in session state. |\n| WSMan    |                    | Root of WsMan Config Storage.                                |\n\nPSDrive中的大多都支持直接路径访问，例如可以通过函数路径，访问一个函数的具体实现。\n\n```powershell\nPS> function hellow(){ Write-Host \"Hellow,Powershell\" }\nPS> $function:hellow\nparam()\nWrite-Host \"Hellow,Powershell\"\n```\n\n#### 特殊的变量：子表达式\n\n由 `$`+圆括号+表达式 构成的变量属于子表达式变量，这样的变量会先计算表达式，然后把表达式的值返回。\n例如 变量`$(3+6)`，可以简写成（3+6）,甚至可以简写成3+6。子表达式变量也可以嵌套在文本中，例如”result=$(3+6)”。\n在处理对象的属性时，会大量的用到表达式变量。例如：\n\n```powershell\nPS> $file=ls Powershell_Cmdlets.html\nPS> $file.Length\n735892\nPS> \"The size of Powershell_Cmdlets.html is $($file.Length)\"\nThe size of Powershell_Cmdlets.html is 735892\n```\n\n其实上面的代码可以简化为：\n\n```powershell\nPS> \"The size of Powershell_Cmdlets.html is $($(ls Powershell_Cmdlets.html).Length)\"\nThe size of Powershell_Cmdlets.html is 735892\n```\n\n\n\n\n\n\n\n\n\n### 05.PowerShell变量的作用域\n\nPowershell所有的变量都有一个决定变量是否可用的作用域。Powershell支持四个作用域：全局、当前、私有和脚本。有了这些作用域就可以限制变量的可见性了，尤其是在函数和脚本中。\n\n如果我们对变量不做特别的声明，Powershell解释器会自动处理和限制变量的作用域。将下面的内容命令保存着至test1.ps1\n$windows = $env:windir\n“Windows Folder: $windows”\n\n然后在控制台给变量$windows赋值，并调用Test.ps1脚本。\n\n```powershell\nPS> $windows=\"Hellow\"\nPS> .\\test.ps1\nWindows Folder: C:\\Windows\nPS> $windows\nHellow\n```\n\n调用脚本时，会分配一个变量$windows，在脚本调用结束后，这个变量被回收，脚本中的变量不会影响脚本外的变量，因为它们在不同的作用域中。powershell会针对每个函数和脚本给它们分配不同的作用域。\n\n#### 更改变量的可见性\n\n你可以很容易的看到没有Powershell解释器自动限制可见性时会发生什么状况，同样是刚才的脚本，刚才的命令，只是在运行脚本时多加上一个点”.” 和一个空格：\n\n```powershell\nPS> $windows=\"Hellow\"\nPS> . .\\test.ps1\nWindows Folder: C:\\Windows\nPS> $windows\nC:Windows\n```\n\n在运行脚本时使用一个原点和空格，Powershell解释器就不会为脚本本身创建自己的变量作用域，它会共享当前控制台的作用域，这种不太灵活但却简单的方法，使用时一定要格外小心。\n\n加强变量可见性限制的优点：清空初始化环境\n可以假设一个场景，如果你在当前控制台不小心定义了一个只读的常量，这个常量既不能更新也不能删除，很是麻烦。但是如果你在脚本中操作这个变量就不成问题，因为脚本有自己的作用域。例如，将下面文本保存为test.ps1，并调用没有任何问题：\n\n```powershell\nNew-Variable a -value 1 -option Constant\n\"Value: $a\"\nPS> .\\test.ps1\nValue: 1\nPS> .\\test.ps1\nValue: 1\n```\n\n但是如果你通过圆点禁用作用域限制，调用test.ps1,就会有异常，因为一个常量不能被创建两次。\n\n```powershell\nPS> . .\\test.ps1\nValue: 1\nPS> . .\\test.ps1\nNew-Variable : A variable with name 'a' already exists.\nAttest.ps1:1 char:13\n+ New-Variable <<<<  a -value 1 -option Constant\n    + CategoryInfo          : ResourceExists: (a:String) [New-Variable], SessionStateException\n    + FullyQualifiedErrorId : VariableAlreadyExists,Microsoft.PowerShell.Commands.NewVariableCommand\n```\n\n所以这种变量的作用域限制可以把变量的冲突降到最小。\n\n#### 设置单个变量的作用域\n\n到目前为止，看到的变量作用域的改变都是全局的，能不能针对某个具体变量的作用域做一些个性化的设置。\n\n**$global**\n全局变量，在所有的作用域中有效，如果你在脚本或者函数中设置了全局变量，即使脚本和函数都运行结束，这个变量也任然有效。\n\n**$script**\n脚本变量，只会在脚本内部有效，包括脚本中的函数，一旦脚本运行结束，这个变量就会被回收。\n\n**$private**\n私有变量，只会在当前作用域有效，不能贯穿到其他作用域。\n\n**$local**\n默认变量，可以省略修饰符，在当前作用域有效，其它作用域只对它有只读权限。\n\n打开Powershell控制台后，Powershell会自动生成一个新的全局作用域。如果增加了函数和脚本，或者特殊的定义，才会生成其它作用域。在当前控制台，只存在一个作用域，通过修饰符访问，其实访问的是同一个变量：\n\n```powershell\nPS> $logo=\"www.pstips.net\"\nPS> $logo\nwww.pstips.net\nPS> $private:logo\nwww.pstips.net\nPS> $script:logo\nwww.pstips.net\nPS> $private:logo\nwww.pstips.net\nPS> $global:logo\nwww.pstips.net\n```\n\n当调用一个已定义的函数，Powershell会生成第二个作用域，它可以对调用者的作用域中的变量执行读操作，但是不能执行写操作。\n\n```powershell\nPS> function f(){ \"var=$var\";$var=\"function inner\";$var }\nPS> $var=\"I am in console.\"\nPS> $var\nI am in console.\nPS> f\nvar=I am in console.\nfunction inner\nPS> $var\nI am in console.\n```\n\n怎样把当前控制台中的变量保护起来，不让它在函数和脚本中被访问，Private修饰符就派上了用场。\n\n```powershell\nPS>  function f(){ \"var=$var\";$var=\"function inner\";$var }\nPS> $private:var=\"i am a private variable in console,other scope can not access me.\"\nPS> f\nvar=\nfunction inner\nPS> $private:var\ni am a private variable in console,other scope can not access me.\n```\n\n对于$private限制的变量能不能在函数中通过$global修改呢？不但不能修改，还会删除当前的$private变量\n\n```powershell\nPS> Function f(){ \"var=$var\";$global:var=\" Try to change variable in function\"}\nPS> $private:var=\"I am a private variable\"\nPS> $private:var\nI am a private variable\nPS> $var\nI am a private variable\nPS> f\nvar=\nPS> $private:var\nPS> $var\nPS>\nPS> $private -eq $null\nTrue\n```\n\n但是$local 修饰的变量则可以通过$global在函数内部更改。\n\n```powershell\nPS> Function f(){ \"var=$var\";$global:var=\" Try to change variable in function\"}\nPS> $var=\"I am a local variable.\"\nPS> $var\nI am a local variable.\nPS> $private:var\nI am a local variable.\nPS> f\nvar=I am a local variable.\nPS> $var\n Try to change variable in function\nPS> $local:var\n Try to change variable in function\n```\n\n\n\n\n\n### 06.PowerShell变量的类型和强类型\n\n变量可以自动存储任何Powershell能够识别的类型信息，可以通过$variable的GetType().Name查看和验证Powershell分配给变量的数据类型。\n\n```powershell\nPS> (10).gettype().name\nInt32\nPS> (9999999999999999).gettype().name\nInt64\nPS> (3.14).gettype().name\nDouble\nPS> (3.14d).gettype().name\nDecimal\nPS> (\"WWW.MOSSFLY.COM\").gettype().name\nString\nPS> (Get-Date).gettype().name\nDateTime\n```\n\nPowershell会给数据分配一个最佳的数据类型；如果一个整数超出了32位整数的上限([int32]::MaxValue),它就会分配一个64位整数的数据类型；如果碰到小数，会分配一个Double类型；如果是文本，Powershell会分配一个String类型；如果是日期或者时间，会被存储为一个Datetime对象。\n这种类型自适应也称作“弱类型”,虽然使用起来方便，但是也会有一些限制，甚至危险。如果powershell选择了一个错误的类型付给变量，可能会引发一些奇怪的现象。例如有一个变量要存储的是即将拷贝文件的个数，可是在赋值时付了一个字符串，Powershell不会去做过多的判断，它会更新这个变量的类型，并且存储新的数据。所以一般专业的程序员或者脚本开发者更喜欢使用“强类型”，哪怕在赋值时类型不兼容的报错，他们也乐意接受。\n喜欢使用强类型的另一个原因是：每一个数据类型都有属于自己的函数。例如DateTime,和XML，尽管这两种类型都可以用纯文本表示，但是使用强类型[DateTime]和[XML],对于数据操作起来更方便，这两个类型的方法可是很丰富奥！\n\n#### 指定类型定义变量\n\n定义变量时可以在变量前的中括号中加入数据类型。例如定义一个Byte类型的变量，因为Byte的定义域为[0,255],一旦尝试使用一个不在定义域中的值赋给该变量就会显示一条错误信息。\n\n```powershell\nPS> [byte]$b=101\nPS> $b\n101\nPS> $b=255\nPS> $b\n255\nPS> $b.gettype()\n\nIsPublic IsSerial Name                                     BaseType\n-------- -------- ----                                     --------\nTrue     True     Byte                                     System.ValueType\n\nPS> $b=256\n\nCannot convert value \"256\" to type \"System.Byte\". Error: \"Value was either too large or too small for an unsigned byte.\n\"\nAt line:1 char:3\n+ $b <<<< =256\n    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException\n    + FullyQualifiedErrorId : RuntimeException\n```\n\n#### 使用固定类型的优点\n\n手动地定义类型的一个重要原因是每个特殊的数据类型都有自己的特殊命令和特殊方法。比如把一个日期字符串赋给一个变量，Powershell不会自动把这个字符串转换成日期对象赋给一个变量，因为Powershell毕竟是机器，没有人那么智能。当你在赋值时指定DateTime类型时，你会发现几乎所有的.Net 中DateTime类型的方法在这里都得到支持。\n\n```powershell\nPS> [DateTime]$date=\"2012-12-20 12:45:00\"\nPS> $date\n\n2012年12月20日 12:45:00\n\nPS> $date.DayOfWeek\nThursday\nPS> $date.DayOfYear\n355\nPS> $date.AddDays(-10)\n\n2012年12月10日 12:45:00\n```\n\nPowershell处理Xml文档也很方便，\n例如有如下LogoTest.xml\n\n```xml\n`<``logotest``>``  ``<``extensions``>``    ``<``e``>.exe</``e``>``    ``<``e``>.dll</``e``>``  ``</``extensions``>``  ``<``files``>``    ``<``f``></``f``>``  ``</``files``>``  ``<``dirs``></``dirs``>``</``logotest``>`\n```\n\n查询.exe 和 .dll结点\n\n```powershell\nPS> [ XML ]$xml=(Get-Content .LogoTestConfig.xml)\nPS> $xml.LogoTest.Extensions.E\n.exe\n.dll\n```\n\nPowershell 默认支持的.NET类型如下。\n[array],[bool],[byte],[char],[datetime],[decimal],[double],[guid],[hashtable],[int16],[int32],[int],[int64],[long],[nullable],[psobject],[regex],[sbyte].[scriptblock],[single],[float],[string],[switch],[timespan],[type],[uint16],[uint32],[uint64],[ XML ]\n\n\n\n\n\n### 07.PowerShell变量的幕后管理\n\n在Powershell中创建一个变量，会在后台生成一个PSVariable对象，这个对象不仅包含变量的值，也包含变量的其它信息，例如”只写保护”这样的描述。\n如果在Powershell中输出一个变量，只会输出这个变量的值。不能够显示它的其它信息，如果想查看一个变量的其它保留信息，就需要变量的基类PSVariable对象，这个可以通过Get-Variable命令得到，下面的例子演示如何查看一个变量的全部信息。\n\n```powershell\nPS> $a=get-date\nPS> Get-Variable a\n\nName                           Value\n----                           -----\na                              2011/12/8 17:52:02\n\nPS> Get-Variable a | fl *\n\nName        : a\nDescription :\nValue       : 2011/12/8 17:52:02\nVisibility  : Public\nModule      :\nModuleName  :\nOptions     : None\nAttributes  : {}\n```\n\n#### 修改变量的选项设置\n\nPowershell处理一个变量的PSVariable对象，主要是为了能够更新变量的选项设置。既可以使用命令Set-Variable，也可以在获取PSvariable对象后直接更改。比如更改一个变量的描述：\n\n```powershell\nPS> $str=\"我是一个变量\"\nPS> $var=Get-Variable str\nPS> $var\n\nName                           Value\n----                           -----\nstr                            我是一个变量\n\nPS> $var | fl *\n\nName        : str\nDescription :\nValue       : 我是一个变量\nVisibility  : Public\nModule      :\nModuleName  :\nOptions     : None\nAttributes  : {}\n\nPS> $var.Description=\"我知道你是一个变量\"\nPS> $var | fl *\nName        : str\nDescription : 我知道你是一个变量\nValue       : 我是一个变量\nVisibility  : Public\nModule      :\nModuleName  :\nOptions     : None\nAttributes  : {}\n```\n\n如果你不想多加一个临时变量$var来存储PSVariable,可以使用Powershell子表达式\n\n```powershell\nPS> (Get-Variable str).Description=\"变量的描述已更改;\"\nPS> Get-Variable str | Format-Table Name,Description\n\nName                                                        Description\n----                                                        -----------\nstr                                                         变量的描述已更改;\n```\n\n#### 激活变量的写保护\n\n可以操作一个变量的选项设置 ，比如给一个变量加上写保护，需要将Option设置为“ReadOnly”\n\n```powershell\nPS> $var=\"mossfly\"\nPS> Set-Variable var -Option \"ReadOnly\"\nPS> (Get-Variable var).Options\nReadOnly\nPS> Set-Variable var -Option \"None\" -Force\nPS> (Get-Variable var).Options\nNone\n```\n\n#### 变量的选项\n\n变量的选项是一个枚举值，包含:\n“None”:默认设置\n“ReadOnly”：变量只读，但是可以通过-Force 选项更新。\n“Constant”：常量一旦声明，在当前控制台不能更新。\n“Private”:只在当前作用域可见，不能贯穿到其它作用域\n“AllScope”：全局，可以贯穿于任何作用域\n\n#### 变量的类型规范\n\n每个变量的都有自己的类型，这个具体的类型存放在PsVariable对象的Attributes[System.Management.Automation.PSVariableAttributeCollection]属性，如果这个Attributes为空，可以给这个变量存放任何 类型的数据，Powershell会自己选择合适的类型。一旦这个Attributes属性确定下来，就不能随意存放数据了。例如给`$var`存放一个整数，属于弱类型，所以Attributes属性为空，这时还可以给它赋值一个字符串。但是如果给`$var`增加强类型，存放一个整数，再给它赋值一个其它类型，解释器会自动尝试转换，如果不能转换就会抛出异常。这时如果你非得更新$var变量的类型，可以使用 (Get-Variable var).Attributes.Clear(),清空Attributes，这样强类型就又转换成弱类型了。\n\n```powershell\nPS> $var=123\nPS> (Get-Variable var).Attributes\nPS> $var.GetType().FullName\nSystem.Int32\nPS> $var=\"字符串\"\nPS>  (Get-Variable var).Attributes\nPS>  $var.GetType().FullName\nSystem.String\nPS> [int]$var=123\nPS> (Get-Variable var).Attributes\n\nTypeId\n------\nSystem.Management.Automation.ArgumentTypeConverterAttribute\n\nPS> $var.GetType().FullName\nSystem.Int32\nPS> $var=\"2012\"\nPS> $var\n2012\nPS> $var.GetType().FullName\nSystem.Int32\nPS> $var=\"2012世界末日\"\nCannot convert value \"2012世界末日\" to type \"System.Int32\". Error: \"Input string was not in a correct format.\"\nAt line:1 char:5\n+ $var <<<< =\"2012世界末日\"     + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException     + FullyQualifiedErrorId : RuntimeException PS> (Get-Variable var).Attributes.Clear()\nPS> (Get-Variable var).Attributes\nPS> $var=\"2012世界末日\"\nPS> $var.GetType().FullName\nSystem.String\n```\n\n#### 验证和检查变量的内容\n\n变量PSVariable对象的Attributes属性能够存储一些附件条件，例如限制变量的长度，这样在变量重新赋值时就会进行验证，下面演示如何限制一个字符串变量的长度为位于2-5之间。\n\n```powershell\nPS> $var=\"限制变量\"\nPS> $condition= New-Object System.Management.Automation.ValidateLengthAttribute -ArgumentList 2,5\nPS> (Get-Variable var).Attributes.Add($condition)\nPS> $var=\"限制\"\nPS> $var=\"射雕英雄传\"\nPS> $var=\"看射雕英雄传\"\nThe variable cannot be validated because the value 看射雕英雄传 is not a valid value for the var variable.\nAt line:1 char:5\n+ $var <<<< =\"看射雕英雄传\"\n    + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException\n    + FullyQualifiedErrorId : ValidateSetFailure\n```\n\n常用的变量内容验证还有5种，分别为：\n**ValidateNotNullAttribute**：限制变量不能为空\n**ValidateNotNullOrEmptyAttribute**：限制变量不等为空，不能为空字符串，不能为空集合\n**ValidatePatternAttribute**:限制变量要满足制定的正则表达式\n**ValidateRangeAttribute**：限制变量的取值范围\n**ValidateSetAttribute**：限制变量的取值集合\n\nValidateNotNullAttribute 例子\n\n```powershell\nPS> $a=123\nPS> $con=New-Object System.Management.Automation.ValidateNotNullAttribute\nPS> (Get-Variable a).Attributes.Add($con)\nPS> $a=8964\nPS> $a=$null\n无法验证此变量，因为值  不是变量 a 的有效值。\n所在位置 行:1 字符: 3\n+ $a <<<< =$null\n    + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException\n    + FullyQualifiedErrorId : ValidateSetFailure\n```\n\nValidateNotNullOrEmptyAttribute 例子，注意@()为一个空数组。\n\n```powershell\nPS> $con=New-Object System.Management.Automation.ValidateNotNullOrEmptyAttribute\nPS> (Get-Variable a).Attributes.clear()\nPS> (Get-Variable a).Attributes.add($con)\nPS> $a=$null\nThe variable cannot be validated because the value  is not a valid value for the a variable.\nAt line:1 char:3\n+ $a <<<< =$null     + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException     + FullyQualifiedErrorId : ValidateSetFailure PS> $a=\"\"\nThe variable cannot be validated because the value  is not a valid value for the a variable.\nAt line:1 char:3\n+ $a <<<< =\"\"     + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException     + FullyQualifiedErrorId : ValidateSetFailure PS> $a=@()\nThe variable cannot be validated because the value System.Object[] is not a valid value for the a variable.\nAt line:1 char:3\n+ $a <<<< =@()\n    + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException\n    + FullyQualifiedErrorId : ValidateSetFailure\n```\n\nValidatePatternAttribute 例子，验证Email格式\n\n```powershell\nPS> $email=\"test@mossfly.com\"\nPS> $con=New-Object System.Management.Automation.ValidatePatternAttribute \"b[A-Z0-9._%+-]+@[A-Z0-9.-]+.[A-Z]{2,4}b\"\nPS> (Get-Variable email).Attributes.Add($con)\nPS> $email=\"abc@abc.com\"\nPS> $email=\"abc@mossfly.com\"\nPS> $email=\"author@gmail.com\"\nPS> $email=\"www@mossfly\"\nThe variable cannot be validated because the value www@mossfly is not a valid value for the email variable.\nAt line:1 char:7\n+ $email <<<< =\"www@mossfly\"\n    + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException\n    + FullyQualifiedErrorId : ValidateSetFailure\n```\n\nValidateRangeAttribute 例子，验证月份1-12\n\n```powershell\nPS> $month=1\nPS> (Get-Variable month).Attributes.Add( $( New-Object System.Management.Automation.ValidateRangeAttribute  -ArgumentList 1,12) )\nPS> $month=10\nPS> $month=12\nPS> $month=18\nThe variable cannot be validated because the value 18 is not a valid value for the month variable.\nAt line:1 char:7\n+ $month <<<< =18     + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException     + FullyQualifiedErrorId : ValidateSetFailure ValidateSetAttribute 例子，验证性别 PS>  $sex=\"男\"\nPS>  $con=New-Object System.Management.Automation.ValidateSetAttribute -ArgumentList \"男\",\"女\",\"保密\"\nPS> (Get-Variable sex).Attributes.Add($con)\nPS> $sex=\"女\"\nPS> $sex=\"不男不女\"\nThe variable cannot be validated because the value 不男不女 is not a valid value for the sex variable.\nAt line:1 char:5\n+ $sex <<<< =\"不男不女\"\n    + CategoryInfo          : MetadataError: (:) [], ValidationMetadataException\n    + FullyQualifiedErrorId : ValidateSetFailure\n```\n\n\n\n\n\n\n\n\n\n## 3.PowerShell数组和哈希表\n\n### 01.PowerShell命令返回数组\n\n当我们把一个命令的执行结果保存到一个变量中，可能会认为变量存放的是纯文本。\n但是，事实上Powershell会把文本按每一行作为元素存为数组。如果一个命令的返回值不止一个结果时，Powershell也会自动把结果存储为数组。\n\n```powershell\nPS C:Powershell> $IPcfg=ipconfig\nPS C:Powershell> $IPcfg\n\nWindows IP Configuration\nEthernet adapter Local Area Connection:\n\n   Connection-specific DNS Suffix  . : ***\n   Link-local IPv6 Address . . . . . : ***\n   IPv4 Address. . . . . . . . . . . : 192.168.140.128\n   Subnet Mask . . . . . . . . . . . : 255.255.252.0\n   Default Gateway . . . . . . . . . : 192.168.140.1\n\nTunnel adapter isatap.mossfly.com:\n\n   Connection-specific DNS Suffix  . : ***\n   Link-local IPv6 Address . . . . . : ***\n   Default Gateway . . . . . . . . . :***\n\nTunnel adapter Teredo Tunneling Pseudo-Interface:\n\n   Media State . . . . . . . . . . . : Media disconnected\n   Connection-specific DNS Suffix  . :\nPS C:Powershell> $IPcfg.Count\n22\n```\n\n#### 使用数组存储结果\n\n判断一个变量是否为数组\n\n```powershell\nPS C:Powershell> $ip=ipconfig\nPS C:Powershell> $ip -is [array]\nTrue\nPS C:Powershell> \"abac\" -is [array]\nFalse\nPS C:Powershell> $str=\"字符串\"\nPS C:Powershell> $str.ToCharArray() -is [array]\nTrue\n```\n\n查看数组的元素个数用$array.Count属性。访问第x个元素，使用$array[x-1]，因为数组是以0开始索引的。\n\n#### 使用管道对数组进一步处理\n\n```powershell\nPS C:Powershell> ipconfig | Select-String \"IP\"\n\nWindows IP Configuration\n   Link-local IPv6 Address . . . . . : ***\n   IPv4 Address. . . . . . . . . . . : ***\n   Link-local IPv6 Address . . . . . : ***\n```\n\n#### 使用真实的对象操作\n\n为什么不愿把IPconfig返回的结果称为对象，因为它不是真正Cmdlet命令，真正的Powershell命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。\n\n```powershell\nPS C:Powershell> ls\n\n    Directory: C:Powershell\n\nMode                LastWriteTime     Length Name\n----                -------------     ------ ----\nd----        2011/11/23     17:25            ABC\nd----        2011/11/29     18:21            myscript\n-a---        2011/11/24     18:30      67580 a.html\n-a---        2011/11/24     20:04      26384 a.txt\n-a---        2011/11/24     20:26      12060 alias\n-a---        2011/11/24     20:27      12060 alias.ps1\n-a---        2011/11/23     17:25          0 b.txt\n-a---        2011/11/23     17:25          0 c.txt\n-a---        2011/11/23     17:25          0 d.txt\n-a---        2011/11/25     11:20        556 employee.xml\n-a---        2011/11/29     19:23      21466 function.ps1\n-a---        2011/11/28     11:12        186 LogoTestConfig.xml\n-a---        2011/11/24     17:37       7420 name.html\n-a---        2011/11/28     15:30         63 ping.bat\n-a---        2011/11/24     17:44     735892 Powershell_Cmdlets.html\n-a---        2011/11/30     16:04       2556 psdrive.html\n-a---         2011/12/2     18:47        140 test.ps1\n-a---        2011/11/23     17:37        242 test.txt\n-a---        2011/11/28     16:42        170 test.vbs\nPS C:Powershell> $result=ls\nPS C:Powershell> $result.Count\n20\n```\n\n数组的每一个元素存放的是一个System.IO.DirectoryInfo对象。\n当我们输出这些对象时，Powershell会自动帮我们把它转换成友好的文本格式。\n\n```powershell\nPS C:Powershell> $result[0].gettype().fullname\nSystem.IO.DirectoryInfo\nPS C:Powershell> $result[0]\n    Directory: C:Powershell\nMode                LastWriteTime     Length Name\n----                -------------     ------ ----\nd----        2011/11/23     17:25            ABC\n```\n\n对于任何一个对象都可以使用Format-List * 查看它所有的属性和方法。\n\n```powershell\nPS C:Powershell> $result[0] | fl *\n\nPSPath            : Microsoft.PowerShell.CoreFileSystem::C:PowershellABC\nPSParentPath      : Microsoft.PowerShell.CoreFileSystem::C:Powershell\nPSChildName       : ABC\nPSDrive           : C\nPSProvider        : Microsoft.PowerShell.CoreFileSystem\nPSIsContainer     : True\nBaseName          : ABC\nMode              : d----\nName              : ABC\nParent            : Powershell\nExists            : True\nRoot              : C:\nFullName          : C:PowershellABC\nExtension         :\nCreationTime      : 2011/11/23 17:25:53\nCreationTimeUtc   : 2011/11/23 9:25:53\nLastAccessTime    : 2011/11/23 17:25:53\nLastAccessTimeUtc : 2011/11/23 9:25:53\nLastWriteTime     : 2011/11/23 17:25:53\nLastWriteTimeUtc  : 2011/11/23 9:25:53\nAttributes        : Directory\n```\n\n\n\n\n\n### 02.PowerShell创建数组\n\n在Powershell中创建数组可以使用逗号。\n\n```powershell\nPS C:Powershell> $nums=2,0,1,2\nPS C:Powershell> $nums\n2\n0\n1\n2\n```\n\n对于连续的数字数组可以使用一个更快捷的方法\n\n```powershell\nPS C:Powershell> $nums=1..5\nPS C:Powershell> $nums\n1\n2\n3\n4\n5\n```\n\n#### 数组的多态\n\n象变量一样如果数组中元素的类型为弱类型，默认可以存储不同类型的值。\n\n```powershell\nPS C:Powershell> $array=1,\"2012世界末日\",([System.Guid]::NewGuid()),(get-date)\nPS C:Powershell> $array\n1\n2012世界末日\n\nGuid\n----\n06a88783-a181-4511-9e41-2780ecbd7924\n\nDisplayHint : DateTime\nDate        : 2011/12/9 0:00:00\nDay         : 9\nDayOfWeek   : Friday\nDayOfYear   : 343\nHour        : 14\nKind        : Local\nMillisecond : 910\nMinute      : 15\nMonth       : 12\nSecond      : 45\nTicks       : 634590369459101334\nTimeOfDay   : 14:15:45.9101334\nYear        : 2011\nDateTime    : 2011年12月9日 14:15:45\n```\n\n#### 空数组和单元素数组\n\n空数组\n\n```powershell\nPS C:Powershell> $a=@()\nPS C:Powershell> $a -is [array]\nTrue\nPS C:Powershell> $a.Count\n0\n```\n\n1个元素的数组\n\n```powershell\nPS C:Powershell> $a=,\"moss\"\nPS C:Powershell> $a -is [array]\nTrue\nPS C:Powershell> $a.Count\n1\n```\n\n\n\n### 04.访问数组\n\n数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是Powershell为了使用方便，直接可以将 -1 作为最后的一个元素的索引。\n\n```powershell\nPS C:Powershell> $books=\"元素1\",\"元素2\",\"元素3\"\nPS C:Powershell> $books[0]\n元素1\nPS C:Powershell> $books[1]\n元素2\nPS C:Powershell> $books[($book.Count-1)]\n元素3\nPS C:Powershell> $books[-1]\n元素3\n```\n\n#### 从数组中选择多个元素\n\n```powershell\nPS C:Powershell> $result=ls\nPS C:Powershell> $result[0,3,5,12]\n    Directory: C:Powershell\n\nMode                LastWriteTime     Length Name\n----                -------------     ------ ----\nd----        2011/11/23     17:25            ABC\n-a---        2011/11/24     20:04      26384 a.txt\n-a---        2011/11/24     20:27      12060 alias.ps1\n-a---        2011/11/24     17:37       7420 name.html\n```\n\n#### 将数组逆序输出\n\n```powershell\nPS C:Powershell> $books=\"元素1\",\"元素2\",\"元素3\"\nPS C:Powershell> $books[($books.Count)..0]\n元素3\n元素2\n元素1\n```\n\n#### 给数组添加和删除元素\n\n因为Powershell数组在内存中是顺序存储的，所以数组的大小必须是确定的，这样才方便分配存储空间，所以给数组增加元素其实相当于创建一个新的数组，只不过之后会把原来的副本删除。在当前数组追加元素可以使用“+=”操作符。\n\n```powershell\nPS C:Powershell> $books=\"元素1\",\"元素2\",\"元素3\"\nPS C:Powershell> $books+=\"元素4\"\nPS C:Powershell> $books\n元素1\n元素2\n元素3\n元素4\n```\n\n要删除第三个元素可是使用：\n\n```powershell\nPS C:Powershell> $num=1..4\nPS C:Powershell> $num\n1\n2\n3\n4\nPS C:Powershell> $num=$num[0..1]+$num[3]\nPS C:Powershell> $num\n1\n2\n4\n# 上面说是删除，其实只是把要留下来的部分拼接\n```\n\n\n\n### 05.复制数组\n\n数组属于引用类型，使用默认的的赋值运算符在两个变量之间赋值只是复制了一个引用，两个变量共享同一份数据。这样的模式有一个弊病如果其中一个改变也会株连到另外一个。所以复制数组最好使用Clone()方法，除非有特殊需求。\n\n```powershell\nPS C:Powershell> $chs=@(\"A\",\"B\",\"C\")\nPS C:Powershell> $chsBak=$chs\nPS C:Powershell> $chsBak[1]=\"H\"\nPS C:Powershell> $chs\nA\nH\nC\nPS C:Powershell> $chs.Equals($chsBak)\nTrue\nPS C:Powershell> $chsNew=$chs.Clone()\nPS C:Powershell> $chsNew[1]=\"Good\"\nPS C:Powershell> $chs.Equals($chsNew)\nFalse\nPS C:Powershell> $chs\nA\nH\nC\n```\n\n\n\n### 06.PowerShell强类型数组\n\nPowershell数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常。\n\n```powershell\nPS C:Powershell> [int[]] $nums=@()\nPS C:Powershell> $nums+=2012\nPS C:Powershell> $nums+=12.3\nPS C:Powershell> $nums+=\"999\"\nPS C:Powershell> $nums+=\"can not convert\"\nCannot convert value \"can not convert\" to type \"System.Int32\". Error: \"Input string was not in a correct format.\"\nAt line:1 char:6\n+ $nums <<<< +=\"can not convert\"\n    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException\n    + FullyQualifiedErrorId : RuntimeException\n```\n\n\n\n\n\n### 07.PowerShell使用哈希表\n\n哈希表存放的是键值对，在哈希表中不再仅仅限制使用数字寻址，可以使用任意类型的数据类型寻址。\n#### 创建哈希表\n之前使用@()创建数组，现在使用`@{}`创建哈希表，使用哈希表的键访问对应的值。\n\n```powershell\nPS C:Powershell> $stu=@{ Name = \"小明\";Age=\"12\";sex=\"男\" }\nPS C:Powershell> $stu\n\nName                           Value\n----                           -----\nName                           小明\nAge                            12\nsex                            男\n\nPS C:Powershell> $stu[\"Name\"]\n小明\nPS C:Powershell> $stu[\"age\"]\n12\nPS C:Powershell> $stu.Count\n3\nPS C:Powershell> $stu.Keys\nName\nAge\nsex\nPS C:Powershell> $stu.Values\n小明\n12\n男\n```\n\n#### 在哈希表中存储数组\n\n可以在创建哈希表时就使用数组，因为创建数组和哈希表的的元素关键字不冲突。一个是逗号，一个是分号。\n\n```powershell\nPS C:Powershell>  $stu=@{ Name = \"小明\";Age=\"12\";sex=\"男\";Books=\"三国演义\",\"围城\",\"哈姆雷特\" }\nPS C:Powershell> $stu\n\nName                           Value\n----                           -----\nBooks                          {三国演义, 围城, 哈姆雷特}\nName                           小明\nAge                            12\nsex                            男\n```\n\n#### 在哈希表中插入新的键值\n\n在哈希表中插入新的键值很方便，象定义变量一样，可以直接拿来使用\n\n```powershell\nPS C:Powershell> $Student=@{}\nPS C:Powershell> $Student.Name=\"令狐冲\"\nPS C:Powershell> $Student.School=\"华山派\"\nPS C:Powershell> $Student\n\nName                           Value\n----                           -----\nName                           令狐冲\nSchool                         华山派\n```\n\n#### 哈希表值的更新和删除\n\n如果要更新键的值，可以直接重写。如果要删除这个键值对，可以使用Remove方法，参数为Key\n\n```powershell\nPS C:Powershell> $stu\n\nName                           Value\n----                           -----\nBooks                          {三国演义, 围城, 哈姆雷特}\nName                           小明\nAge                            12\nsex                            男\n\nPS C:Powershell> $stu.Name=\"赵强\"\nPS C:Powershell> $stu.Name\n赵强\nPS C:Powershell> $stu.Remove(\"Name\")\nPS C:Powershell> $stu\n\nName                           Value\n----                           -----\nBooks                          {三国演义, 围城, 哈姆雷特}\nAge                            12\nsex                            男\n```\n\n#### 使用哈希表格式化输出\n\n在Powershell中哈希表的一个有趣的应用可以用来格式化文本输出。Powershell许多命令的输出结果都是以表格的形式，当然可以使用Format-Table自定义表格格式，例如：\n\n```powershell\nPS C:Powershell> Dir | Format-Table\n\n    Directory: C:Powershell\n\nMode                LastWriteTime     Length Name\n----                -------------     ------ ----\nd----        2011/11/23     17:25            ABC\nd----        2011/11/29     18:21            myscript\n\nPS C:Powershell> Dir | Format-Table FullName,Mode\n\nFullName                                                    Mode\n--------                                                    ----\nC:PowershellABC                                           d----\nC:Powershellmyscript                                      d----\nC:Powershella.html                                        -a---\n```\n\n上述的命令只能限制表格输出那些列，隐藏那些列。但是对于列的宽度，列标题无能为力，但是有了哈希表就可以实现更多自定义了。\n表格的每一个列包含四个属性：\n**Expression**:绑定的表达式\n**Width**:列宽度\n**Label:**列标题\n**Alignment:**列的对齐方式\n\n```powershell\nPS C:Powershell> $column1 = @{expression=\"Name\"; width=30;label=\"filename\"; alignment=\"left\"}\nPS C:Powershell> $column2 = @{expression=\"LastWriteTime\"; width=40;label=\"last modification\"; alignment=\"right\"}\nPS C:Powershell> ls | Format-Table $column1, $column2\n\nfilename                                              last modification\n--------                                              -----------------\nABC                                                 2011/11/23 17:25:53\nmyscript                                            2011/11/29 18:21:28\na.html                                              2011/11/24 18:30:13\n```\n\n\n\n\n\n\n\n## 4.PowerShell管道\n\n### 01.PowerShell使用管道\n\n管道并不是什么新事物，以前的Cmd控制台也有重定向的命令，例如Dir | More可以将结果分屏显示。\n传统的Cmd管道是基于文本的，但是Powershell是基于对象。\n\n```powershell\nPS> ls | Sort-Object -Descending Name | Select-Object Name,Length,LastWriteTime | ConvertTo-Html | Out-File ls.html\n\nPS> Get-Content .ls.html\n```\n\n| Name                    | Length | LastWriteTime       |\n| ----------------------- | ------ | ------------------- |\n| test.vbs                | 170    | 2011/11/28 16:42:03 |\n| test.txt                | 242    | 2011/11/23 17:37:37 |\n| test.ps1                | 140    | 2011/12/2 18:47:35  |\n| psdrive.html            | 2556   | 2011/11/30 16:04:00 |\n| Powershell_Cmdlets.html | 735892 | 2011/11/24 17:44:37 |\n| ping.bat                | 63     | 2011/11/28 15:30:04 |\n| name.html               | 7420   | 2011/11/24 17:37:28 |\n| myscript                |        | 2011/11/29 18:21:28 |\n| ls.html                 | 434    | 2011/12/14 11:22:30 |\n| LogoTestConfig.xml      | 186    | 2011/11/28 11:12:08 |\n| function.ps1            | 21466  | 2011/11/29 19:23:58 |\n| employee.xml            | 556    | 2011/11/25 11:20:33 |\n| d.txt                   | 0      | 2011/11/23 17:25:23 |\n| c.txt                   | 0      | 2011/11/23 17:25:23 |\n| b.txt                   | 0      | 2011/11/23 17:25:23 |\n| alias.ps1               | 12060  | 2011/11/24 20:27:24 |\n| alias                   | 12060  | 2011/11/24 20:26:36 |\n| ABC                     |        | 2011/11/23 17:25:53 |\n| a.txt                   | 26384  | 2011/11/24 20:04:31 |\n| a.html                  | 67580  | 2011/11/24 18:30:13 |\n\n首先列出当前目录下的目录和文件，然后根据文件名降序排列，再投影文件名，文件大小，文件的修改时间，转换成Html格式，输出到当前目录的ls.html\n\n#### 面向对象的管道\n\n上面的例子属于面向对象的管道，每个命令的末尾可以使用新的命令对上个命令的结果做进一步处理，除非管道是以输出命令结束的。就像Sort-Object一样，对文件的列表进行排序，需要告诉它排序的关键字，按照升序还是降序。ls的返回值为一个数组，数组中的每一个元素都是一个对象，对象的每一个属性都可以作为Sort-Object的排序关键字。但是排序时必须指定一个具体的关键字，因为Powershell所传递的对象可能有很多属性。不像普通的文本，对象的信息都是结构化的，因此也使得Powershell的管道变得更加强大和方便。\n\n#### 转换命令执行的结果为文本\n\n在执行Powershell命令时，解释器会默认在命令的结尾追加一个管道命令，Out-Default，这样可以将原来的对象结果以文本的形式显示在控制台上，但是并没有将结果进行转换，所以可以继续使用其它管道对对象的结果进行操作，但是一旦使用了诸如ConvertTo-Html这样的命令后，就会将结果转换成固定格式的纯文本。\n\n常用的对管道结果进一步处理的命令有：\n\n**Compare-Object**: 比较两组对象。\n**ConvertTo-Html**: 将 Microsoft .NET Framework 对象转换为可在 Web 浏览器中显示的 HTML。\n**Export-Clixml**: 创建对象的基于 XML 的表示形式并将其存储在文件中。\n**Export-Csv**: 将 Microsoft .NET Framework 对象转换为一系列以逗号分隔的、长度可变的 (CSV) 字符串，并将这些字符串保存到\n一个 CSV 文件中。\n**ForEach-Object**: 针对每一组输入对象执行操作。\n**Format-List**: 将输出的格式设置为属性列表，其中每个属性均各占一行显示。\n**Format-Table**: 将输出的格式设置为表。\n**Format-Wide**: 将对象的格式设置为只能显示每个对象的一个属性的宽表。\n**Get-Unique**: 从排序列表返回唯一项目。\n**Group-Object**: 指定的属性包含相同值的组对象。\n**Import-Clixml**: 导入 CLIXML 文件，并在 Windows PowerShell 中创建相应的对象。\n**Measure-Object**: 计算对象的数字属性以及字符串对象（如文本文件）中的字符数、单词数和行数。\n**more**: 对结果分屏显示。\n**Out-File**: 将输出发送到文件。\n**Out-Null**: 删除输出，不将其发送到控制台。\n**Out-Printer**: 将输出发送到打印机。\n**Out-String**: 将对象作为一列字符串发送到主机。\n**Select-Object:** 选择一个对象或一组对象的指定属性。它还可以从对象的数组中选择唯一对象，也可以从对象数组的开头或末尾选\n择指定个数的对象。\n**Sort-Object**: 按属性值对象进行排序。\n**Tee-Object**: 将命令输出保存在文件或变量中，并将其显示在控制台中。\n**Where-Object**: 创建控制哪些对象沿着命令管道传递的筛选器。\n\n#### 管道的处理模式\n\n当我们把许多命名组合成一个管道时，可能会感兴趣每一个命令的执行时是顺序执行还是同时执行？通过管道处理结果实际上是实时的。这就是为什么存在两个管道模式：\n**顺序模式（较慢）：**在顺序模式中管道中同一时间只执行一条命令，只有当前一条命令的所有执行完毕，才会把所有结果交付给下一条 命令。这种模式速度慢并且耗内存，因为必须需要很多次分配空间存储中间结果。\n**流模式（较快）：**流模式会立即执行所有命令，同一时间可能在执行多条命令。前一条命令可能会产生多个结果，但是一旦产生其中一个结果，就会立即交付给下一条命令处理。这样的流模式节省比较节省内存，可能管道的某个任务还在执行，但是已经有部分结果输出了。减少了中间结果的保存。\n\n#### 管道命令的阻塞\n\n可以使用Sort-Object对管道的结果进行排序，但是有时候排序可能导致整个操作系统阻塞，因为排序命令的的执行属于顺序模式，必须得上一条命令的结果全部完成，才能排序。\n因此在使用这类命令时，要注意操作对象的大小，和它们需要的内存。例如这条命令：\nDir C: -recurse | Sort-Object\n-recurse 选项是递归查询子目录，可想而知系统盘的文件和目录有多大。这条命令一旦运行起来，需要等很长很长的时间，甚至可能导致系统崩溃，得重启电脑。你可以在执行这条命令时，打开任务管理器查看Powershell进程的内存占用在以每秒种几十兆的速率增加。\n到底哪些命令可能系统阻塞，要视命令的实现方式以及处理的对象大小决定，例如Sort-object导致阻塞的原因肯定是由于技术实现上采用的是内排序，没有使用外排序。但是象Out-Host -paging 这样的命令属于流出来模式，就一般不会导致系统阻塞。\n\n\n\n\n\n## 05.powershell的错误和异常处理\n\npowershell 判断上一个程序是否运行成功，powershell中所有异常处理的方法(lastexitcode  try catch  trap异常处理)\n\n### 01.$LASTEXITCODE和$?\n\n类似于linux的shell脚本，powershell也可以用记录程序退出码的方式判断命令是否执行成功\n\n其中\n\n1. **$?**表示最后一个操作的执行状态。如果最后一个操作成功，则包含 TRUE，失败则包含 FALSE。\n\n2. $LASTEXITCODE则是返回上一次执行的退出码，因为linux程序通常用退出码0表示执行成功，所以我们判断$LASTEXITCODE是否为0就能判断上次程序执行是否成功。\n\n总的来说$LASTEXITCODE，逻辑上还要多绕一圈，所以平时方便起见用**$?**就是了。\n\n\n\n### 02.trap\n\ntrap关键词可以指定让程序终结的错误发生时，执行一系列语句。\n\n* trap的默认行为是在执行完statement block里的语句 后显示错误，然后会继续执行脚本或者函数\n* 在trap中使用break可以实现显示错误，然后退出执行\n* 如果想要不显示错误继续执行，可以用continue\n\n\n\n#### 语法\n\n```powershell\ntrap [[<error type>]] {<statement list>}\n```\n\nstatement list就是终结错误发生时，会执行的语句。\n\n错误类型定义了trap的处理范围\n\n#### trap处理所有终结错误\n\n没有类型定义的trap会在所有错误发生的时候执行。\n\n当一个让程序终结的错误没有找到其他处理的脚本或命令，就会执行trap里面的语句，\n\n下面是一个例子\n\n```powershell\ntrap {\"Error found.\"}\n```\n\n```powershell\nfunction TrapTest {\n    trap {\"Error found.\"}\n    nonsenseString\n}\n\nTrapTest\n```\n\n会出现下面的错误\n\n```powershell\nError found.\nnonsenseString:\nLine |\n   3 |      nonsenseString\n     |      ~~~~~~~~~~~~~~\n     | The term 'nonsenseString' is not recognized as the name of a cmdlet,\nfunction, script file, or operable program. Check the spelling of the name, or\nif a path was included, verify that the path is correct and try again.\n```\n\ntrap 中使用`$_ `,也就是powershell自动生成的当前对象，就会被替换成输出的错误\n\n```powershell\nfunction TrapTest {\n    trap {\"Error found: $_\"}\n    nonsenseString\n}\n\nTrapTest\n\n\nError found: The term 'nonsenseString' is not recognized as the name of a\ncmdlet, function, script file, or operable program. Check the spelling of the\nname, or if a path was included, verify that the path is correct and try again.\nnonsenseString:\nLine |\n   3 |      nonsenseString\n     |      ~~~~~~~~~~~~~~\n     | The term 'nonsenseString' is not recognized as the name of a cmdlet,\nfunction, script file, or operable program. Check the spelling of the name, or\nif a path was included, verify that the path is correct and try again.\n```\n\n\n\n**注意: trap可以在一个作用域代码块（scope）的任何地方定义，即使定义在一个代码块的底部，也会捕获整个代码块的错误**\n\n#### trap处理特定的错误\n\n下面是只处理没有找到命令的错误的trap，trap的使用的是.net的异常类型\n\n```powershell\ntrap [System.Management.Automation.CommandNotFoundException]\n    {\"Command error trapped\"}\n```\n\n下面是系统异常类型，System.Management.Automation.CommandNotFoundException是继承自System.Exception的\n\n```powershell\ntrap [System.Exception] {\"An error trapped\"}\n```\n\n当多个trap同时存在的时候powershell会匹配最精确特定的trap，如下\n\n```powershell\ntrap {\"Other terminating error trapped\" }\ntrap [System.Management.Automation.CommandNotFoundException] {\n  \"Command error trapped\"\n}\nnonsenseString\n\nCommand error trapped\nnonsenseString:\nLine |\n   5 |  nonsenseString\n     |  ~~~~~~~~~~~~~~\n     | The term 'nonsenseString' is not recognized as the name of a cmdlet,\nfunction, script file, or operable program. Check the spelling of the name, or\nif a path was included, verify that the path is correct and try again.\n\n```\n\n#### trap捕获错误的作用域\n\ntrap捕获错误以后，会执行trap内部的语句，但是错误处后续的代码还会继续执行\n\n下面是在函数内部发生了错误的情况，错误被内部的trap捕获，并且函数的返回语句被正常执行\n\n```powershell\nfunction function1 {\n    trap { \"An error: \" }\n    NonsenseString\n    \"function1 was completed\"\n}\n\nfunction1\n\nAn error:\nNonsenseString:\nLine |\n   3 |      NonsenseString\n     |      ~~~~~~~~~~~~~~\n     | The term 'NonsenseString' is not recognized as the name of a cmdlet,\nfunction, script file, or operable program. Check the spelling of the name, or\nif a path was included, verify that the path is correct and try again.\nfunction1 was completed\n\n```\n\n下面的例子trap语句被放到函数外面，能够捕获到函数内部的错误，但是函数的返回语句没有被执行\n\n```powershell\nfunction function2 {\n    NonsenseString\n    \"function2 was completed\"\n}\n\ntrap { \"An error: \" }\n\nfunction2\n\nAn error:\nNonsenseString:\nLine |\n   2 |      NonsenseString\n     |      ~~~~~~~~~~~~~~\n     | The term 'NonsenseString' is not recognized as the name of a cmdlet,\nfunction, script file, or operable program. Check the spelling of the name, or\nif a path was included, verify that the path is correct and try again.\n```\n\n也就是说，trap如果在函数的外部，就可以实现捕获到错误就停止函数运行的功能。\n\n**注意:多个trap定义相同类型的错误条件的时候，只有最高处定义的trap会被使用**\n\n```powershell\nRemove-Item -ErrorAction Stop ThisFileDoesNotExist\ntrap { \"whoops 1\"; continue }\ntrap { \"whoops 2\"; continue }\n```\n\n**注意：trap语句的定义域取决于它编译的位置，如果它在一个函数或者脚本中，那么当函数或脚本退出时，他们内部的trap语句就会被删除**\n\n看下面的例子，函数外的错误没有被函数内的trap捕获\n\n```powershell\nfunction function1 {\n    trap { \"An error: \" }\n    \n    \"function1 was completed\"\n}\nNonsenseString\n\nfunction1 was completed\nNonsenseString: C:\\Projects\\base\\test\\testexit.ps1:6:1\nLine |\n   6 |  NonsenseString\n     |  ~~~~~~~~~~~~~~\n     | The term 'NonsenseString' is not recognized as a name of a cmdlet, function,\n     | script file, or executable program. Check the spelling of the name, or if a\n     | path was included, verify that the path is correct and try again.\n```\n\n\n\n#### 使用break和continue关键字\n\n在trap中使用break和continue可以决定终结错误发生时，继续运行还是停止\n\n默认没有break关键字的情况下是会继续运行的，也会输出错误\n\n```powershell\nfunction break_example {\n    trap {\n        \"Error trapped\"\n        break\n    }\n    1/$null\n    \"Function completed.\"\n}\n\nbreak_example\n\nError trapped\nParentContainsErrorRecordException:\nLine |\n   6 |      1/$null\n     |      ~~~~~~~\n     | Attempted to divide by zero.\n\n```\n\n使用continue语句，powershell将从错误中恢复，并且不会输出错误流\n\n```powershell\nfunction continue_example {\n    trap {\n        \"Error trapped\"\n        continue\n    }\n    1/$null\n    \"Function completed.\"\n}\n\ncontinue_example\n\nError trapped\nFunction completed.\n```\n\n\n\n综上，trap是一种比较简单的广范围的错误处理方式，对于更细粒度的错误处理，建议使用try catch语句\n\n### 03.try catch finally\n\ntry 捕获的错误，会被自动保存到$Error变量里面，powershell会寻找catch语句来处理错误。\n\n这个语法就和c#的异常处理比较像\n\n#### 语法\n\n```powershell\ntry {<statement list>}`\ncatch [[<error type>][',' <error type>]*] {<statement list>}\nfinally {<statement list>}\n```\n\n\n\n#### 捕获错误\n\n```powershell\ntry { NonsenseString }\ncatch { \"An error occurred.\" }\n\nAn error occurred.\n```\n\n#### 使用多个catch语句\n\n```powershell\ntry {\n   $wc = new-object System.Net.WebClient\n   $wc.DownloadFile(\"http://www.contoso.com/MyDoc.doc\",\"c:\\temp\\MyDoc.doc\")\n}\ncatch [System.Net.WebException],[System.IO.IOException] {\n    \"Unable to download MyDoc.doc from http://www.contoso.com.\"\n}\ncatch {\n    \"An error occurred that could not be resolved.\"\n}\n```\n\n#### 在try catch语句中使用trap\n\n当try语句中包含trap，即使声明了catch语句，也会执行trap，如果trap的位置比try更高，并且没有catch语句，trap也会获得控制，即使父级作用域中包含匹配的catch语句。\n\n#### 访问错误信息 ACCESSING EXCEPTION INFORMATION\n\ncatch语句中的$_就包含了错误信息\n\n```powershell\ntry { NonsenseString }\ncatch {\n  Write-Host \"An error occurred:\"\n  Write-Host $_\n}\n\nAn Error occurred:\nThe term 'NonsenseString' is not recognized as the name of a cmdlet, function,\nscript file, or operable program. Check the spelling of the name, or if a path\nwas included, verify that the path is correct and try again.\n```\n\n你还可以用$_打印堆栈信息\n\n```powershell\ntry { NonsenseString }\ncatch {\n  Write-Host \"An error occurred:\"\n  Write-Host $_.ScriptStackTrace\n}\n\nAn Error occurred:\nat <ScriptBlock>, <No file>: line 2\n```\n\n#### 使用FINALLY来释放资源\n\n不管try块是否遇到错误，finally语句都会执行。即使catch中使用exit退出脚本，或者使用ctrl+c中止脚本都会执行。"}},"__N_SSG":true}